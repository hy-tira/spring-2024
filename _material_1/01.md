---
title: 1. Introduction
slug: chap01
hide: true
sections:
  - What is an algorithm?
  - What is a data structure?
  - Implementing an algorithm
  - Efficiency of algorithms
---

# 1. Introduction

The aim of the course _Data Structures and Algorithms_ is to advance your programming skills and teach you techniques and ways of thinking that help you in implementing programs that are correct and efficient in all circumstances.

The course uses the Python language but the techniques taught on the course are applicable to other programming languages too. The course involves a lot of programming but some theoretical ideas and concepts are covered too.

## What is an algorithm?

An _algorithm_ is a method for solving some computational problem. An algorithm implemented in some programming language can be executed on a computer.

The _input_ of an algorithm is the set of initial data provided to the algorithm. The _output_ of an algorithm is the answer produced by the algorithm by the end of its execution. In Python an algorithm can be implemented as a function, and then typically the input is given as the function parameters and the output is the return value.

Let us consider an example, where the algorithm is given a list of numbers and the task is to count how many of the numbers are even. For example if the list is `[5, 4, 1, 7, 9, 6]`, the desired answer is `2`, because `4` and `6` are the even numbers.

This task can be solved with an algorithm that goes through the numbers on the list and maintains a variable that stores the count of even numbers seen so far. The algorithm can be implemented as a Python function `count_even`:

```python
def count_even(numbers):
    result = 0
    for x in numbers:
        if x % 2 == 0:
            result += 1
    return result
```

The function can be tested with the following main program:

```python
print(count_even([1, 2, 3])) # 1
print(count_even([2, 2, 2, 2, 2])) # 5
print(count_even([5, 4, 1, 7, 9, 6])) # 2
```

Here the function is tested with three different lists. For each test, the desired answer is given as comment at the end of the line. When the program is executed, it prints out:

```console
1
5
2
```

Thus the function produces the desired output, at least for these three lists, and it seems we have created a correctly working algorithm for the task. 

## What is a data structure?

A _data structure_ is a way of storing data within a program. The basic data structure in Python is the list, but there are many other standard data structures too. The choice of data structures is an important part of designing an algorithm, because the data structures have a big effect on the efficiency of the algorithm.

On this course, we learn about many data structures and their uses in designing algorithms. We cover many standard Python data structures, and learn to implement data structures not provided by Python and other programming languages.

## Implementing an algorithm

Any algorithm can be implemented with a few basic programming constructs. In Python, these basic constructs are:

* variables
* operators (`+`, `=` etc.)
* conditionals (`if`)
* loops (`for`, `while`)
* lists
* functions
* classes

In addition to these, programming languages have many other features that can help shorten the code, but do not affect the fundamental operating logic of the code. They can be used in implementing algorithms but are not necessary.

Let us return to the earlier example function `count_even` that was implemented with the basic constructs:

```python
def count_even(numbers):
    result = 0
    for x in numbers:
        if x % 2 == 0:
            result += 1
    return result
```
This can be implemented more compactly with a special Python construct, the generator expression:

```python
def count_even(numbers):
    return sum(x % 2 == 0 for x in numbers)
```
Here the `sum` function encloses a generator expression that computes the value of the expression `x % 2 == 0` for each element `x`of the list. The possible values are `True` and `False`, but when they are summed up, each `True` is counted as the number `1` and each `False` as the number `0`. Thus the result of the summation is the count of even numbers.

The latter function is much shorter but its fundamental operation is the same as the former one's. Both functions go through the numbers on the list and add up the times when an even number is encountered. The operating logic is the same in both cases.

The advantage of the first function is that it is easier to explain to a person who is not familiar with Python special constructs. The function could be easily translated into other programming languages, for example JavaScript:

```js
function countEven(numbers) {
    let result = 0;
    for (let x of numbers) {
        if (x % 2 == 0) result++;
    }
    return result;
}
```
The advantage of the second function is that is more concise and perhaps more in the style of Python language. Even though the basic constructs are sufficient, it can be interesting to learn more special constructs too.

## Efficiency of algorithms

The same task can be solved by different algorithms, and there can be big differences in their efficiencies. Often the goal is to find an efficient algorithm that solves the task quickly.

Let us consider a task, where we are given a list of numbers, and the goal is to find the largest difference between any two numbers. For example, when the list is `[3, 2, 6, 5, 8, 5]`, the desired answer is `6`, because the largest difference is between the numbers `2` and `8`.

Three algorithms for solving the task are given below:

{: .code-title }
Algorithm 1
```python
def max_diff(numbers):
    result = 0
    for x in numbers:
        for y in numbers:
            result = max(result, abs(x - y))
    return result
```

This algorithm has two nested `for` loops that go through all ways to choose two numbers from the list. The algorithm copmputes the difference using the `abs` (abstract value) function and remembers the largest difference it has encounter so far.

{: .code-title }
Algorithm 2
```python
def max_diff(numbers):
    numbers = sorted(numbers)
    return numbers[-1] - numbers[0]
```
The idea of the second algorithm is that the biggest difference must be between the smallest number and the largest number in the list.

The algorithm first sorts the list using the `sorted` function. Then the smallest number is in the beginning (index `0`) and the largest is at the end (index `-1`) of the list.

{: .code-title }
Algorithm 3
```python
def max_diff(numbers):
    return max(numbers) - min(numbers)
```

The third algorithm is based on finding the smallest and largest numbers too, but instead of sorting, it uses the functions `min` and `max`.

***

The efficiency of an algorithm can be studied with a test program that runs the algorithm with a given input and measures the execution time. It is often a good idea to write the test program so that it generates a random input of a given size. Then it is easy to test the algorithm with inputs of different sizes.

Below is a program that test efficiency of the `max_diff` function:

```python
import random
import time

def max_diff(numbers):
    ...

n = 1000
print("n:", n)
random.seed(1337)
numbers = [random.randint(1, 10**6) for _ in range(n)]

start_time = time.time()
result = max_diff(numbers)
end_time = time.time()

print("result:", result)
print("time:", round(end_time - start_time, 2), "s")
```

The value of the variable `n` is the length of the list used in the test. The function `random.seed` sets seed number (here `1337`) of the random number generator so that it will always generate the same random numbers. This makes comparisons between test runs easier and more reliable. A list of `n` random numbers between $$1 \dots 10^6$$ is created with the function `random.randint` and a generator expression.

The program measures the execution time using the `time.time` function. The function returns the time since the beginning of the year 1970 in seconds. The difference between the times before and after the execution of the algorithm tells how many seconds did the execution take. The time is rounded to two decimals with the function 'round`.

The execution of the test program outputs something like this:

```console
n: 1000
result: 999266
time: 0.09 s
```

This means that the input to the algorithm was a list of length `1000`, the output of the was `999266`, and the execution of the algorithm took `0.09` seconds.

The following table shows the execution times of the above three algorithms for inputs of different sizes on the test computer:

| List length `n` | Algorithm 1 | Algorithm 2 | Algorithm 3 |
| --- | --- | --- | --- |
| 1000 | 0.17 s | 0.00 s | 0.00 s |
| 10000 | 15.93 s | 0.00 s | 0.00 s |
| 100000 | -- | 0.01 s | 0.00 s |
| 1000000 | -- | 0.27 s | 0.02 s |

The table shows big differences in the efficiencies of the algorithms. Algorithm 1 is slow on large inputs, and the tests with the two largest inputs were aborted because the execution took too much time. Algorithms 2 and 3, on the other hand, are efficient on large inputs too. The largest input exposes a difference between Algorithms 2 and 3 too, although the difference is not as big as compared to Algorithm 1. 

<!--
## Mikä vaikuttaa tehokkuuteen?

Algoritmin tehokkuuteen vaikuttavia asioita ovat:

### Algoritmin idea

Keskeinen algoritmin tehokkuuteen vaikuttava asia on algoritmin idea eli miten algoritmi laskee vastauksen.

Äskeisessä vertailussa algoritmin 1 ideana oli käydä läpi kaikki tavat, miten listalta voidaan valita kaksi lukua. Tämä on hidasta, koska erilaisia tapoja on paljon. Algoritmeissa 2 ja 3 oli parempi idea: riittää selvittää pienin ja suurin luku eikä käydä läpi kaikkia mahdollisia vaihtoehtoja.

Algoritmin idean tehokkuutta voidaan arvioida laskemalla algoritmin aikavaativuus. Tutustumme tähän tarkemmin tämän osan lopussa.

### Algoritmin toteutustapa

Tiettyyn ideaan perustuva algoritmi voidaan toteuttaa koodina useilla eri tavoilla. Usein algoritmia voi olla mahdollista tehostaa miettimällä toteutus tarkemmin.

Tarkastellaan esimerkkinä algoritmia 1, jonka ideana on käydä läpi kaikki tavat valita listalta kaksi lukua:

```python
def max_diff(numbers):
    result = 0
    for x in numbers:
        for y in numbers:
            result = max(result, abs(x - y))
    return result
```

Tässä toteutuksessa molemmat silmukat käyvät läpi koko listan, minkä takia algoritmi vertailee jokaista lukuparia kahteen kertaan. Esimerkiksi jos lista on `[1, 2]`, ensin `x` on 1 ja `y` on 2 ja myöhemmin `x` on 2 ja `y` on 1.

Idea voidaan toteuttaa tehokkaammin käymällä läpi luvut indeksien avulla niin, että ensimmäinen luku on aina toisen luvun vasemmalla puolella:

```python
def max_diff(numbers):
    result = 0
    for i in range(0, n):
        for j in range(i + 1, n):
            result = max(result, abs(numbers[i] - numbers[j]))
    return result
```

Tämä on tehokkaampi toteutus, koska nyt jokainen lukupari käydään läpi vain kerran. Tämän ansiosta algoritmi toimii tehokkaammin:

| Listan koko `n` | Alkuperäinen | Tehostettu |
| --- | --- | --- |
| 1000 | 0.17 s | 0.10 s |
| 10000 | 15.93 s | 9.57 s |
| 100000 | -- | -- |
| 1000000 | -- | -- |

Kuitenkin koska algoritmin idea on hidas, paremmasta toteutuksesta on vain rajallinen hyöty. Algoritmi on edelleen hidas suuremmilla listoilla.

### Algoritmin suoritusympäristö

Samasta ohjelmointikielestä voi olla olemassa useita toteutuksia, joiden tehokkuudessa on eroa. Niinpä algoritmin tehokkuuteen vaikuttaa, millä toteutuksella se suoritetaan.

Pythonin yleensä käytetty toteutus on CPython, mutta lisäksi on olemassa toinen toteutus PyPy, joka on usein tehokkaampi. Algoritmin 1 suoritusajat toteutuksilla ovat:

| Listan koko `n` | CPython-suoritus | PyPy-suoritus |
| --- | --- | --- |
| 1000 | 0.17 s | 0.01 s |
| 10000 | 15.93 s | 0.55 s |
| 100000 | -- | 53.37 s |
| 1000000 | -- | -- |

Tässä tapauksessa algoritmi toimii paljon nopeammin, kun se suoritetaan PyPy-ympäristössä.

### Algoritmin toteutuskieli

```cpp
int max_diff(vector<int> numbers) {
    int result = 0;
    for (auto x : numbers) {
        for (auto y : numbers) {
            result = max(result, abs(x - y));
        }
    }
    return result;
}
```

| Listan koko `n` | CPython | PyPy | C++
| --- | --- | --- |
| 1000 | 0.17 s | 0.01 s | 0.01 s |
| 10000 | 15.93 s | 0.55 s | 0.08 s |
| 100000 | -- | 53.37 s | 6.68 s |
| 1000000 | -- | -- | -- |

## Mikä ei vaikuta tehokkuuteen?
-->

## Time complexity

_Time complexity_ is a mathematical way of measuring the efficiency of an algorithm. Time complexity is a powerful tool in designing algorithms, bacause it provides a convenient way to estimate how efficient an algorithm is.

Time complexity is usually expressed with the $$O$ notation using the variable $$n$$ to represent the size of the input. For example, if the input is a list, $$n$$ is the length of the list, and if the input is a string, $$n$$ is the length of the string.

The time complexity is an arithmetic expression involving the input size $$n$$. Common time conplexities include:

Time complexity | Name of complexity class
--- | ---
$$O(1)$$ | Constant
$$O(\log n)$$ | Logarithmic
$$O(n)$$ | Linear
$$O(n \log n)$$ | --
$$O(n^2)$$ | Quadratic
$$O(n^3)$$ | Cubic

The time complexity of an algorithm can be determined using the following rules:

Algoritmin aikavaativuus voidaan usein laskea seuraavien sääntöjen avulla:

### 1. Individual commands

If the algorithm contains individual commands, whose execution time does not depend on the size of the input, their time complexity is $$O(1)$$.

For example, the following algorithm has time complexity $$O(1)$$:

```python
def distinct(a, b, c):
    if a == b and a == c:
        return 1
    if a == b or a == c or b == c:
        return 2
    return 3
```

The input of the algorithm is three numbers and the algorithm finds out how many different numbers it was given. For example `distinct(3, 4, 3)` returns `2`. The algorithm consists of individual commands and thus its time complexity is $$O(1)$$. 

### 2. Time complexity of loop

If the algorithm contains a loop, and the number of rounds in the loop is about the same as the size of the input, the time complexity of the loop is $$O(n)$$.

For example, the time complexity of the following algorithms is $$O(n)$$:

```python
def count_even(numbers):
    count = 0
    for x in numbers:
        if x % 2 == 0:
            count += 1
    return count
```

The time complexity is $$O(n)$$ because it contains a loop that goes through the elements of the list. The number of rounds is the same as the length of the list, and the time complexity of the code inside the loop is $$O(1)$$.

### 3. Nested loops

If an algorithm contains loops inside loops, the time complexity is obtained by multiplying the loop time complexities.

For example, the following algorithm has time complexity $$O(n)$$:

```python
def has_sum(numbers, x):
    for a in numbers:
        for b in numbers:
            if a + b == x:
                return True
    return False
```

The algorithms determines if the list has two numbers that sum up to `x`.
The time complexity is $$O(n^2)$$, because it has two nested loops each with a time complexity $$O(n)$$.

More generally, if an algorithm has $$k$$ nested loops each with time complexity $$O(n)$$, the time complexity of the algorithm is $$O(n^k)$$.

### 4. Sequential code segments

If the algorithm consists of multiple code segments in sequence, the whole time complexity is the maximum of the segment time complexities.

For example, the time complexity of the following algorithm is $$O(n)$$:

```python
def even_odd_diff(numbers):
    even_count = 0
    for x in numbers:
        if x % 2 == 0:
            even_count += 1
            
    odd_count = 0
    for x in numbers:
        if x % 2 != 0:
            odd_count += 1
            
    return abs(even_count - odd_count)
```

The algorithm computes difference in the counts of even and odd numbers.
The algorithm consists of two loops in sequence, with each loop having the time complexity $$O(n)$$. Thus the time complexity of the whole algorithms is $$O(n)$$.

<!--
***

Tällä kurssilla ja muutenkin algoritmien suunnittelussa riittää usein käyttää yllä olevia sääntöjä aikavaativuuden määrittämiseen. Joskus on kuitenkin hyödyllistä tuntea myös suuruusluokkiin liittyvä [matemaattinen tausta](../suuruusluokat).
-->
