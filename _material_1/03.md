---
title: 3. Efficient algorithms
slug: chap03
hide: true
sections:
  - Outline of an efficient algorithm
  - "Example: Stock trading"
  - Is the algorithm correct?
  - "Example: Bit string"
  - "Example: List splitting"
  - "Example: Sublist"
---

# 3. Efficient algorithms

The topic of this and the following two chapters is the design of efficient algorithms. We aim for algorithms that execute efficiently even when the input size $$O(n)$$ is big.

A common situation in algorithm design is one where it is easy to design a straightforward algorithm that solves the problem with two nested loops in $$O(n^2)$$ time. This kind of an algorithm can be called a _brute force_ algorithm. But if $$n$$ is big, a more efficient algorithm may be necessary.

In practice, an efficient algorithm is often required to have a time complexity $$O(n)$$ or $$O(n \log n)$$. We will first take a look at $$O(n)$$ time algorithms that scan through the input in one loop while maintaining some additional data. The time complexity $$O(n \log n)$$ often arises from the use of sorting, which will be covered in Chapter 5. 

Tässä ja kahdessa seuraavassa luvussa tutustumme tehokkaiden algoritmien suunnitteluun. Tavoitteemme on saada aikaan algoritmeja, jotka toimivat tehokkaasti myös silloin, kun syötteen koko $$n$$ on suuri.

Tavallinen tilanne algoritmien suunnittelussa on, että on helppoa laatia suoraviivainen algoritmi, joka ratkaisee tehtävän kahdella silmukalla ajassa $$O(n^2)$$. Tällaista algoritmia voidaan kutsua _raa'an voiman_ (_brute force_) algoritmiksi. Tämä ei kuitenkaan riitä $$n$$:n ollessa suuri, vaan tarvitaan tehokkaampi algoritmi.

Käytännössä tehokkaan algoritmin aikavaativuus on usein $$O(n)$$ tai $$O(n \log n)$$. Tutustumme ensin $$O(n)$$-algoritmeihin, jotka käyvät syötteen läpi yhdellä silmukalla ja pitävät muistissa sopivalla tavalla valittua tietoa. Aikavaativuus $$O(n \log n)$$ liittyy usein järjestämiseen, jota käsittelemme luvussa 5.

## Outline of an efficient algorithm

A typical efficient algorithm might be structured something like this:

```python
# define variables
for ...
    # efficient code
# return answer
```

An efficient algorithm typically has a single for-loop that goes through the input from left to right. The code inside loop is efficient so that each round in the loop takes $$O(1)$$ time. Then the time complexity of the whole algorithm is $$O(n)$$.

A loop in an efficient algorithm may contain the following:

* updates of variable values using other variables or individual elements of the input
* arithmetic expressions related to a variable update
* if-commands that affects the variable updates

But the loop may not contain:

* other loops that go through the input
* slow operations that processes the input (for example, `count` or the slice operation `[:]`)
* slow function call (for example, `sum`, `min` or `max` applied to the whole input)

A major challenge in designing many algorithms is to figure out how to implement the algorithm so that the loop contains only efficient code. We will next see examples of how to achieve this. 

Tällaisessa algoritmissa on yksi for-silmukka, joka käy läpi algoritmille annetun syötteen vasemmalta oikealle. Silmukan sisällä tulee olla tehokasta koodia niin, että silmukan jokainen kierros vie aikaa $$O(1)$$. Tällöin koko algoritmin aikavaativuus on $$O(n)$$.

Tehokkaan algoritmin silmukan sisällä saa olla seuraavia:

* muuttujan arvon päivitys muiden muuttujien tai yksittäisten syötteen alkioiden perusteella
* laskutoimitus, joka liittyy muuttujan arvon päivittämiseen
* if-komento, joka vaikuttaa sihen, miten muuttujia päivitetään

Sen sijaan silmukan sisällä ei saa olla seuraavia:

* toinen silmukka, joka käy läpi syötteen alkioita
* hidas syötettä käsittelevä operaatio (esim. metodi `count` tai slice-operaatio `[:]`)
* hidas funktiokutsu (esim. `sum`, `min` tai `max` koko syötteelle)

Monen algoritmin suunnittelussa keskeinen haaste on keksiä, miten algoritmin saa toteutettua niin, että silmukan sisällä on vain tehokasta koodia. Näemme seuraavaksi esimerkkejä siitä, miten silmukan sisällä oleva tehokas koodi voidaan toteuttaa.


## Example: Stock trading

{: .note-title }
Task
<div class="note" markdown="1">

You are given the price of a stock for $$n$$ days. Your task is figure out the highest profit you could have made if you had bought the stock on one day and sold it on another day.

Consider the following situation:

Annettuna on osakkeen hinta $$n$$ päivän ajalta. Tehtäväsi on selvittää, mikä olisi ollut suurin mahdollinen tuotto, jos olisit ostanut osakkeen yhtenä päivänä ja myynyt sen toisena päivänä.

Tarkastellaan esimerkkinä seuraavaa tilannetta:

Day   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
Price | 3 | 7 | 5 | 1 | 4 | 6 | 2 | 3

Here the highest profit is 6 - 1 = 5, achieved by buying on day 3 and selling on day 5.

Tässä suurin mahdollinen tuotto saadaan ostamalla osake päivänä 3 ja myymällä se päivänä 5. Tuotoksi tulee 6 – 1 = 5.

</div>

A straightforward algorithm for solving this problem iterates through all combinations of buying and selling days. The following function `best_profit` implements the algorithm:

Suoraviivainen algoritmi tehtävän ratkaisemiseen on käydä läpi kaikki vaihtoehdot osakkeen ostopäivän ja myyntipäivän valintaan kahdella silmukalla. Seuraava funktio `best_profit` toteuttaa algoritmin:

```python
def best_profit(prices):
    n = len(prices)
    best = 0
    for i in range(n):
        for j in range(i + 1, n):
            best = max(best, prices[j] - prices[i])
    return best
```

The the variable `i` indicates the buying day and the variable `j` the selling day. The profit is computed for each combination of days, and the variable `best` remembers the highest profit encounted so far. This is a correct algorithm but its time complexity is $$O(n^2)$$, which makes it slow for big $$n$$. We would like to have a more efficient algorithm that has only one loop.

Let us consider how a single loop algorithm might work. When the loop reaches a given day, what is the biggest profit possible if we sell on that day? The profit is maximized if we bought the stock at the lowest price on any of the preceding days. Thus each possible selling day should be paired with lowest buying price on the preceding days.

This idea is implemented in the following algorithm:

Ideana on, että muuttuja `i` valitsee myyntipäivän ja muuttuja `j` valitsee ostopäivän. Jokaiselle valinnalle lasketaan näin saatava tuotto osakekaupasta, ja muuttuja `best` pitää muistissa parasta tuottoa. Tämä on toimiva algoritmi, mutta ongelmana on, että algoritmin aikavaativuus on $$O(n^2)$$ eli se on hidas, kun $$n$$ on suuri. Algoritmia tulisi tehostaa niin, että siinä ei ole kahta silmukkaa vaan vain yksi silmukka.

Mietitään nyt, millainen algoritmin tulisi olla, jotta siinä olisi vain yksi silmukka. Kun olemme tietyn päivän kohdalla, miten suuri voitto on mahdollinen, jos myymme osakkeen kyseisenä päivänä? Voitto on suurin silloin, kun olemme ostaneet osakkeen aiemmin mahdollisimman halvalla. Niinpä meidän kannattaa valita ostohinnaksi osakkeen halvin hinta kyseiseen päivään mennessä.

Voimme toteuttaa tällaisen algoritmin seuraavasti:

```python
def best_profit(prices):
    n = len(prices)
    best = 0
    for i in range(n):
        min_price = min(prices[0:i+1])
        best = max(best, prices[i] - min_price)
    return best
```

The algorithm computes the lowest price preceding day `i` into the variable `min_price`. This is implemented with the `min` function over the beginning part `prices[0:i-1]` of the list. Then the highest profit possible when selling on day `i` can be computed as `prices[i] - min_price`.

This is again a correct algorithm, but still not efficient. The problem is that computing `min_price` takes too much time, because the function `min` has to scan through all the preceding elements, which takes $$O(n)$$ time. In essence, there is a hidden second loop inside the function `min`. Thus the total time complexity is still $$O(n^2)$$.

We can fix the problem as follows:

Ideana on laskea silmukassa muuttujaan `min_price` osakkeen halvin hinta päivään `i` mennessä. Tämä on toteutettu hakemalla pienin alkio `min`-funktiolla listan alkuosassa `prices[0:i+1]`. Tämän jälkeen saamme laskettua kaavalla `prices[i] - min_price` voiton, kun myymme osakkeen päivänä `i`.

Tämä on toimiva algoritmi ja siinä on vain yksi silmukka, mutta algoritmi ei ole vielä tehokas. Ongelmana on, että muuttujan `min_price` laskeminen on hidasta silmukassa, koska `min`-funktio käy läpi listan `prices` alkuosan. Tämä vie aikaa $$O(n)$$, minkä vuoksi algoritmin aikavaativuus on edelleen $$O(n^2)$$.

Voimme kuitenkin korjata ongelman seuraavasti:

```python
def best_profit(prices):
    n = len(prices)
    best = 0
    min_price = prices[0]
    for i in range(n):
        min_price = min(min_price, prices[i])
        best = max(best, prices[i] - min_price)
    return best
```

Now the value of the variable `min_price` is not computed from scratch each time, but instead each new value is computed efficiently from the previous one. With this modification, each round of the loop needs only $$O(1)$$ time and the time complexity of the whole algorithm is $$O(n)$$, making it efficient.

Notice that the function `min` can be slow or fast. Computing the smallest value on a long list is slow, but computing the smaller of two values is fast.

Nyt muuttujaa `min_price` ei lasketa tyhjästä silmukan joka kierroksella, vaan uusi arvo lasketaan tehokkaasti edellisen arvon perusteella. Tämän muutoksen ansiosta silmukan jokainen kierros vie aikaa $$O(1)$$, jolloin algoritmin aikavaativuus on $$O(n)$$ ja algoritmi toimii tehokkaasti.

Huomaa, että funktion `min` käyttäminen voi olla sekä hidasta että tehokasta. Jos funktiolla haetaan listan pienin alkio, tämä on hidasta. Jos kuitenkin funktiolla valitaan pienempi kahdesta arvosta, tämä on tehokasta.

## Is the algorithm correct?

The operating logic of an efficient algorithm is often more complicated than that of a straightforward brute force algorithm. This can make it more difficult to determine if the algoritm works correctly.

A useful way to test the correctness of an algorithm is to _compare_ its output a simpler correct algorithm. This can be automated so that the algorithms are tested on a large number of random inputs. For example, the above algorithms can be tested as follows:

Tehokkaan algoritmin toimintalogiikka on yleensä monimutkaisempi kuin suoraviivaisessa raa'an voiman algoritmissa. Tämän vuoksi voi olla vaikea tietää, onko toteutettu algoritmi varmasti toimiva.

Kätevä tapa saada tietoa tehokkaan algoritmin toimivuudesta on _verrata_ sen toimintaa suoraviivaiseen algoritmiin. Tämä voidaan automatisoida niin, että algoritmeja testataan suurella määrällä satunnaisia syötteitä. Esimerkiksi voimme testata äskeisen tehtävän algoritmeja seuraavaan tapaan:

```python
import random

def best_profit_brute(prices):
    ...

def best_profit_fast(prices):
    ...

while True:
    n = random.randint(1, 20)
    prices = [random.randint(1, 10) for _ in range(n)]

    result_brute = best_profit_brute(prices)
    result_fast = best_profit_fast(prices)

    print(prices, result_brute, result_fast)
   
    if result_brute != result_fast:
        print("ERROR")
        break
```

Here the function `best_profit_brute` implements the brute force algorithm and the function `best_profit_fast`implements the efficient algorithm. The main program generates random lists with the length $$n$$ in the range $$1 \dots 20$ and the prices in the range $$1 \dots 10$$. After each test run, the program prints out the list used in the test and the outputs of the two functions. The output might look like this:

Tässä funktio `best_profit_brute` toteuttaa raa'an voiman algoritmin ja funktio `best_profit_fast` toteuttaa tehokkaan algoritmin. Pääohjelma testaa algoritmeja luomalla satunnaisia listoja, joissa $$n$$ on välillä $$1 \dots 20$$ ja hinnat ovat välillä $$1 \dots 10$$. Jokaisen testin jälkeen ohjelma tulostaa listan sisällön sekä funktioiden palauttamat arvot. Ohjelman tulostus voisi alkaa seuraavasti:

```
[2, 4, 5, 4, 2, 4, 8, 7, 5] 6 6
[8, 8, 8, 3, 6, 4, 9, 3, 2, 5, 4, 5, 2] 6 6
[9, 3, 1, 5, 8, 9, 3] 8 8
[3, 6, 7] 4 4
[6, 8, 7, 10, 8, 6, 1, 1, 2, 2, 8, 9, 10] 9 9
[4, 5, 3, 4, 5] 2 2
[3, 6, 2] 3 3
[4, 3, 8, 10, 7, 3, 4, 7, 5, 1, 7, 8, 7] 7 7
...
```

The matching outputs provides some assurance of the correctness of the efficient algorithm. If the program finds an input, where the outputs differ, it prints an error and exits. We can then try to figure out why the algorith produced an incorrect output.

Tällaisen testauksen avulla saa hyvää varmuutta siitä, että tehokas algoritmi on toimiva. Jos löytyy syöte, jossa algoritmi antaa väärän tuloksen, ohjelma ilmoittaa tästä ja testaus päättyy. Tämän jälkeen ohjelman antaman syötteen avulla voi koettaa tutkia, miksi algoritmi ei  toimi oikein.

## Example: bit string

{: .note-title }
Task
<div class="note" markdown="1">
You are given a bit string consisting of the characters `0` and `1`. How many ways can you select two positions in the bit string so that the left position contains the bit `0` and the right position contains the bit `1`?
  
Annettuna on bittijono, joka muodostuu merkeistä `0` ja `1`. Monellako tavalla voit valita bittijonosta kaksi kohtaa niin, että vasemmassa kohdassa on bitti `0` ja oikeassa kohdassa on bitti `1`?

Consider the following situation:

Tarkastellaan esimerkkinä seuraavaa tilannetta:

Kohta | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
Bitti | 0 | 1 | 0 | 0 | 1 | 0 | 1 | 1 |

Here there are 12 such pairs of positions.

Tässä tilanteessa mahdollisia tapoja on 12.

</div>

A straightforward solution is to iterate through all possible pairs of positions and count the number of times with `0` on the left and `1` on the right:

Suoraviivainen tapa ratkaista tehtävä on käydä läpi kaikki tavat valita vasen ja oikea kohta ja laskea, monessako kohdassa vasen bitti on `0` ja oikea bitti on `1`:

```python
def count_ways(bits):
    n = len(bits)
    result = 0
    for i in range(n):
        for j in range(i + 1, n):
            if bits[i] == '0' and bits[j] == '1':
                result += 1
    return result
```

Again, the algorithm is too slow as its time complexity is $$O(n^2)$$.

Let us consider how we could solve the problem with a single loop. As with the stock trading problem, a good approach is to deal with all pairs ending at the current position simultaneously. More precisely, at a position `i`, we need an efficient way of counting the pairs with a bit `1` at position `i` and a bit `0` at a position before `i`.

If the bit at position `i` is `0`, the count is obviously 0. If the bit at position `i` is `1`, we need to know, how many of the preceding positions contain a `0` bit. We get this number efficiently be keeping track of the number of `0` bits seen so far. Here is an implementation of this idea:

Tässä ongelmana on jälleen, että aikavaativuus on $$O(n^2)$$ eli algoritmi on liian hidas.

Mietitään, miten selviäisimme yhdellä silmukalla. Kuten osakkeen hinnan laskemisessa, tässäkin tehtävässä hyvä lähestymistapa on käsitellä jokaisessa kohdassa kyseiseen kohtaan päättyvät ratkaisut. Tarkemmin voimme koettaa laskea kussakin bittijonon kohdassa `i` tehokkaasti tavat, joissa oikea bitti `1` on kohdassa `i` ja vasen bitti `0` on ennen kohtaa `i`.

Jos kohdassa `i` on bitti `1`, tässä kohdassa voi olla oikea kohta. Tässä tapauksessa vasen kohta voi olla mikä tahansa kohta ennen kohtaa `i`, jossa on bitti `0`. Niinpä saamme aikaan tehokkaan algoritmin, kun pidämme muistissa, montako bittiä `0` on tullut vastaan silmukan aikana. Voimme toteuttaa algoritmin näin:

```python
def count_ways(bits):
    n = len(bits)
    result = 0
    zeros = 0
    for i in range(len(bits)):
        if bits[i] == '0':
            zeros += 1
        if bits[i] == '1':
            result += zeros
    return result
```

The code executed within the loop depends on whether the bit at the current position is `0` or `1`. If it is `0`, we increment the variable `zeros` that stores the number of zeros seen so far. If it is `1`, we add the value `zeros` to the variable `result`, corresponding to the desired pairs with `i` as the right position.

The algorithm has a single loop that scans through the input, and the code inside the loop needs $$O(1)$$ time. Thus the algorithm is efficient as it runs in $$O(n)$ time.

Silmukan sisällä suoritettava koodi riippuu siitä, onko bitti `0` vai `1`. Jos bitti on `0`, kasvatetaan muuttujan `zeros` arvoa. Tämän avulla joka kohdassa tiedetään, montako bittiä `0` on tullut vastaan tähän mennessä. Jos taas bitti on `1`, lisätään muuttujaan `result` muuttujan `zeros` arvo. Tämä laskee tehokkaasti mukaan tulokseen kaikki tavat, joissa oikea bitti on kohdassa `i`.

Algoritmissa on yksi silmukka, joka käy syötteen läpi, ja silmukan sisällä olevan koodin aikavaativuus on $$O(1)$$. Tämän ansiosta algoritmin aikavaativuus on $$O(n)$$ ja se toimii tehokkaasti.

## Example: List splitting

{: .note-title }
Task
<div class="note" markdown="1">
You are given a list containing $$n$$ integers. Your task is to count how many ways one can split the list into two parts so that both parts have the same total sum of elements.

Consider the following example list:

Annettuna on lista, jossa on $$n$$ kokonaislukua. Tehtäväsi on laskea, monellako tavalla listan voi halkaista kahteen osaan niin, että molemmissa osissa lukujen summa on sama.

Tarkastellaan esimerkkinä seuraavaa listaa:

Kohta | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
Luku | 1 | -1 | 1 | -1 | 1 | -1 | 1 | -1 |

Here the number of ways is 3. We split the list between positions 1 and 2, between positions 3 and 4, and between positions 5 and 6.

Tässä tilanteessa mahdollisia tapoja on 3. Voimme halkaista listan kohtien 1 ja 2, kohtien 3 ja 4 tai kohtien 5 ja 6 välistä.

</div>

Here is a straightforward algorithm for the task:

Suoraviivainen algoritmi tehtävään on seuraava:

```python
def count_splits(numbers):
    n = len(numbers)
    result = 0
    for i in range(n - 1):
        left_sum = sum(numbers[0:i+1])
        right_sum = sum(numbers[i+1:])
        if left_sum == right_sum:
            result += 1
    return result
```

The algorithm goes through all ways of splitting the list, and computes the sums of the resulting parts into the variables `left_sum` and `right_sum`. If the sums are the same, the count stored in the variable `result` is incremented by one. The time complexity of the algorithm is $$O(n^)$$, because computing the two sums takes $$O(n)$$ time.

Since the algorithm goes through the elements from left to right, we can compute `left_sum` more efficiently by incrementing the previous value at each step:

Algoritmi käy läpi kaikki tavat halkaista lista ja laskee muuttujiin `left_sum` ja `right_sum` listan vasemman ja oikean osan summan halkaisun jälkeen. Jos summat ovat samat, muuttujan `result` arvo kasvaa yhdellä. Algoritmin aikavaativuus on $$O(n^2)$$, koska muuttujien `left_sum` ja `right_sum` laskeminen vie aikaa $$O(n)$$.

Koska silmukka käy listan läpi vasemmalta oikealle, voimme tehostaa algoritmia laskemalla summaa `left_sum` samaa tahtia silmukan kanssa:

```python
def count_splits(numbers):
    n = len(numbers)
    result = 0
    left_sum = 0
    for i in range(n - 1):
        left_sum += numbers[i]
        right_sum = sum(numbers[i+1:])
        if left_sum == right_sum:
            result += 1
    return result
```

This is still not fast enough, because computing `right_sum` is still slow, and the the trick we used for `left_sum` does not work for `right_sum`, because the list is processed in left-to-right order. Even with the faster computation of `left_sum`, the time complexity is still $$O(n^2)$$.

The key observation is that if we know the total sum of the list in addition to `left_sum`, we can compute `right_sum` efficiently:

Tämä ei ole kuitenkaan riittävä tehostus, koska muuttujan `right_sum` laskeminen on edelleen hidasta eikä siihen voi tehdä vastaavaa muutosta. Vaikka muuttuja `left_sum` lasketaan tehokkaasti, algoritmi vie edelleen aikaa $$O(n^2)$$.

Voimme kuitenkin tehostaa algoritmia lisää hyödyllisen havainnon avulla: jos tiedämme vasemman osan summan lisäksi _koko_ listan summan, voimme laskea näiden tietojen avulla tehokkaasti oikean osan summan.

```python
def count_splits(numbers):
    n = len(numbers)
    result = 0
    left_sum = 0
    total_sum = sum(numbers)
    for i in range(n - 1):
        left_sum += numbers[i]
        right_sum = total_sum - left_sum
        if left_sum == right_sum:
            result += 1
    return result
```

Since the total sum does not change during the loop, we can compute it into the variable `total_sum` before the loop. This takes $$O(n)$$ time but it is done only once. Then inside the loop, `right_sum` can be computed as the diffirence `total_sum - left_sum`. The total time complexity of the obtained algorithm is $$O(n)$$.

Koska koko listan summa ei muutu silmukan aikana, voimme laskea sen ennen silmukkaa muuttujaan `total_sum`. Tämä vie aikaa $$O(n)$$ mutta se tehdään vain kerran ennen silmukkaa. Tämän jälkeen silmukassa `right_sum` saadaan laskettua tehokkaasti kaavalla `total_sum - left_sum`. Tuloksena on algoritmi, jonka aikavaativuus on $$O(n)$$.

## Example: sublist

{: .note-title }
Task
<div class="note" markdown="1">
You are given a list containing $$n$$ integers. How many ways can we choose a sublist that contains exactly two distinct integers?

For example, the list $$[1,2,3,3,2,2,4,2]$$ has $$14$$ such sublists.

Annettuna on lista, jossa on $$n$$ kokonaislukua. Monellako tavalla listasta voidaan valita osalista, jossa esiintyy tasan kaksi eri lukua?

Esimerkiksi listassa $$[1,2,3,3,2,2,4,2]$$ haluttu vastaus on $$14$$.

</div>

This task is harder than the ones above, but the same approach works here too: go through the list, and at each position, compute how many solutions end at the current positions.

With the example list, we should obtain the following counts at each position:

Tämä tehtävä on selvästi vaikeampi kuin aiemmat käsitellyt tehtävät, mutta tässäkin toimii aiemmin hyväksi havaittu tekniikka: käydään läpi lista ja lasketaan jokaisessa kohdassa, montako ratkaisua päättyy kyseiseen kohtaan.

Esimerkkitapauksessa tulisi saada laskettua seuraavat tulokset:

Indeksi | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
Luku | 1 | 2 | 3 | 3 | 2 | 2 | 4 | 2
Tulos | 0 | 1 | 1 | 1 | 3 | 3 | 2 | 3

For example, the count at the position 5 is 3, because the sublists ending at the position 5 include $$[2,3,3,2,2]$$, $$[3,3,2,2]$$ and $$[3,2,2]$$.

We can compute the count of sublists ending at a position `i` efficiently with two variables: `a` points at the nearest preceding position that contains a different value than the one in the position `i`, and `b` points to the nearest preceding position whose value differs from both of the values at the positions `i` and `a`. These two values are useful, because a valid sublist ending at `i` must start after the position `b` and before or at position `a`. Thus the number of valid sublists ending at `i` can be counted with the formula `a - b'.

For example, when `i` is at the position 5, we have the following situation:

Esimerkiksi kohdassa 5 haluttu tulos on 3, koska kohtaan 5 päättyvät osalistat ovat $$[3,2,2]$$, $$[3,3,2,2]$$ ja $$[2,3,3,2,2]$$.

Voimme laskea kohtaan `i` päättyvien osalistojen määrän tehokkaasti kahden muuttujan avulla: `a` osoittaa edelliseen kohtaan, jossa on eri luku kuin kohdassa `i`, ja `b` osoittaa edelliseen kohtaan, jossa on eri luku kuin kohdissa `i` ja `a`. Nämä muuttujat ovat hyödyllisiä, koska osalistan tulee alkaa kohdan `b` jälkeen ja viimeistään kohdassa `a`. Niinpä kohtaan `i` päättyvien osalistojen määrä saadaan laskettua kaavalla `a - b`.

Esimerkiksi kun `i` on kohdassa 5, tilanne on seuraava:

Indeksi | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
Luku | 1 | 2 | 3 | 3 | 2 | 2 | 4 | 2
| `b` | | | `a` | | `i` | |

Here `a` points to the position 3 containg the value 3, and `b` points to the position `0` containing the value `1`. The count of sublists is obtained as 3 - 0 = 3.

The variables of `a` and `b` must be updated every time when the value at the position `i` is different from the value at the position `i-1`. There are two cases to consider:

1. If the value at `i` is different from the value at `a`, `b` moves to the position `a` and `a` moves to the position `i-1`.
2. If the value at `i` is equal to the value at `a`, `a` again moves to `i-1` but `b` does not move.

Let us consider happens next in our example. When `i` moves from the position 5 to the position 6, the values at `i` and `a` are different and we have the case 1. Thus `a` moves to the position 6 – 1 = 5 and `b` moves to the position 3:

Tässä tapauksessa `a` on kohdassa 3, jossa on luku 3, ja `b` on kohdassa 0, jossa on luku 1. Osalistojen määrä saadaan laskettua kaavalla 3 – 0 = 3.

Silmukan edetessä muuttujia `a` ja `b` täytyy päivittää sopivasti aina, kun kohdassa `i` on eri luku kuin kohdassa `i - 1`. Tässä on kaksi tapausta:

1. Jos kohdassa `i` on eri luku kuin kohdassa `a`, `b` siirtyy kohtaan `a` ja `a` siirtyy kohtaan `i - 1`.
2. Jos kohdassa `i` on sama luku kuin kohdassa `a`, vain `a` siirtyy kohtaan `i - 1`.

Esimerkissä on tapaus 1, kun `i` siirtyy kohtaan 6, ja tapaus 2, kun `i` siirtyy kohtaan 7. Muuttujat `a` ja `b` päivittyvät seuraavasti:

Indeksi | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
Luku | 1 | 2 | 3 | 3 | 2 | 2 | 4 | 2
| | | | `b` | | `a` | `i` |

When `i` moves from the position 6 to the position 7, the values at `i` and `a` are equal and we have the case 2. occurs when 'i' moves to the position 7. Thus `a` moves to the position 7 – 1 = 6 and `b` does not move:

Indeksi | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
Luku | 1 | 2 | 3 | 3 | 2 | 2 | 4 | 2
| | | | `b` | | | `a` | `i`

This idea leads to an efficient algorithm that can be implemented as follows:

Algoritmi voidaan toteuttaa seuraavasti:

```python
def count_lists(numbers):
    n = len(numbers)
    a = b = -1
    result = 0
    for i in range(1, n):
        if numbers[i] != numbers[i - 1]:
            if numbers[i] != numbers[a]:
                b = a
            a = i - 1
        result += a - b
    return result
```

Initially, both `a` and `b' have the value `-1`, which indicates that are not yet pointing to any list position. It is straightforward to verify that the algorithm computes the correct sublist counts in the beginning while `a' or `b` still has the value `-1`. 

Tässä toteutuksessa `a` ja `b` ovat alussa `-1` tarkoittaen, että ne eivät vielä osoita mihinkään listan kohtaan. Tämän ansiosta algoritmi laskee oikein osalistojen määrän myös listan alkuosassa.
