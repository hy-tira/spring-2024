---
title: 4. Hashing
slug: chap04
hide: true
sections:
  - Joukko
  - "Esimerkki: Montako eri lukua?"
  - Sanakirja
  - "Esimerkki: Moodi"
  - "Esimerkki: Kierrokset"
  - "Esimerkki: Soittolista"
  - "Esimerkki: Listan summat"
  - Miten hajautus toimii?
  - Hajautus muissa kielissä
---

# 4. Hashing

_Hashing_ is a technique frequently used in implementing efficient algorithms. In Python, the data structures `set` and `dict` (dictionary) are based on hashing.

In this chapter, we look at data structures based on hashing and their use in algorithm design. We will also cover some theory underlying the data structures.

_Hajautus_ (_hashing_) on tekniikka, jota käytetään usein tehokkaiden tietorakenteiden toteuttamisessa. Pythonissa tietorakenteet joukko (`set`) ja sanakirja (`dict`) perustuvat hajautukseen.

Tutustumme tässä luvussa hajautukseen perustuviin tietorakenteisiin ja niiden käyttämiseen algoritmien suunnittelussa. Lisäksi tutustumme tietorakenteiden taustalla olevaan teoriaan.

## Set

The Python data structure `set`, based on hashing, maintains a set of elements. The operations on the data structure include:

* the method `add` adds an element to the set
* the operator `in` finds if a given element is in the set
* the method `remove` removes an element from the set

The data structure is implemented so that all of the above operations take $$O(1)$$ time. 

Pythonin tietorakenne `set` eli joukko on hajautukseen perustuva tietorakenne, joka pitää yllä alkioiden joukkoa. Tietorakenne tarjoaa seuraavat operaatiot:

* metodi `add` lisää alkion joukkoon
* operaattori `in` tarkastaa, onko alkio joukossa
* metodi `remove` poistaa alkion joukosta

Joukko on toteutettu niin, että kaikki yllä olevat operaatiot tapahtuvat tehokkaasti ajassa $$O(1)$$.

### Example

The following code creates a set `numbers` and adds elements to the set:

Seuraava koodi luo joukon `numbers` ja lisää sinne alkioita metodilla `add`:

```python
numbers = set()

numbers.add(1)
numbers.add(2)
numbers.add(3)

print(numbers) # {1, 2, 3}
```

We can also create a set from a list:

Joukko voidaan myös luoda suoraan listan perusteella:

```python
numbers = set([1, 2, 3])

print(numbers) # {1, 2, 3}
```

The operator `in` tests if an element is in the set:

Operaattori `in` tarkastaa, kuuluuko tietty alkio joukkoon:

```python
print(3 in numbers) # True
print(4 in numbers) # False
```

And we can remove an element from the set:

Metodi `remove` puolestaan poistaa alkion joukosta:

```python
print(numbers) # {1, 2, 3}
numbers.remove(2)
print(numbers) # {1, 3}
```

### List vs. set

A list and a set are similar data structures in that both maintain a collection of elements and support additions and removals. However, there are significant differences in their efficiency and properties.

Lista ja joukko ovat tietyllä tavalla samantapaisia tietorakenteita, koska molemmissa voi lisätä, etsiä ja poistaa alkioita. Kuitenkin tietorakenteiden tehokkuudessa ja ominaisuuksissa on suuria eroja.

**Efficiency**

Adding an element to a list is efficient, but finding an element and removing it can be slow.

With a set, adding elements, finding elements and removing elements are all efficient operations.

Listassa alkion lisääminen on tehokasta, mutta on hidasta etsiä alkiota listasta sekä poistaa alkio listasta.

Joukossa on tehokasta lisätä alkio joukkoon, etsiä alkiota joukosta sekä poistaa alkio joukosta.

Operation | List | Set
--- | --- | ---
Alkion lisääminen (`append`/`add`) | $$O(1)$$ | $$O(1)$$
Alkion etsiminen (`in`) | $$O(n)$$ | $$O(1)$$
Alkion poistaminen (`remove`) | $$O(n)$$ | $$O(1)$$

**Indexing**

In a list, elements can be accessed using an index:

Listassa alkioita voidaan käsitellä indeksien perusteella:

```python
numbers = [1, 2, 3]
print(numbers[1]) # 2
```

A set does not support indexing:

Joukon alkioihin sen sijaan ei voida viitata indekseillä:

```python
numbers = set([1, 2, 3])
print(numbers[1]) # TypeError: 'set' object is not subscriptable
```

**Repeated elements**

In a list, an element can occur multiple times:

Listassa sama alkio voi esiintyä useita kertoja:

```python
numbers = []

numbers.append(5)
numbers.append(5)
numbers.append(5)

print(numbers) # [5, 5, 5]
```

A set contains an element only once. Adding an element that is already in the set has no effect:

Joukossa sama alkio voi esiintyä enintään kerran. Jos alkio lisätään monta kertaa joukkoon, tällä ei ole vaikutusta:

```python
numbers = set()

numbers.add(5)
numbers.add(5)
numbers.add(5)

print(numbers) # {5}
```

## Example: How many numbers?

{: .note-title }
Task
<div class="note" markdown="1">

You are given a list. How many distinct numbers it contains?

For example, when the list is $$[3,1,2,1,5,2,2,3]$$, the desired answer is $$4$$, becausethe distinct numbers are $$1$$, $$2$$, $$3$$ and $$5$$.

Annettuna on lista lukuja. Montako eri lukua listalla on?

Esimerkiksi kun lista on $$[3,1,2,1,5,2,2,3]$$, haluttu vastaus on $$4$$, koska eri luvut ovat $$1$$, $$2$$, $$3$$ ja $$5$$.

</div>

**Slow solution (list)**

We could solve the task using a list as follows:

Voisimme ratkaista tehtävän listan avulla seuraavasti:

```python
def count_distinct(numbers):
    seen = []
    for x in numbers:
        if x not in seen:
            seen.append(x)
    return len(seen)
```

The algorithm goes through the numbers and adds a number to a list `seen` if it is not there already. At the end, the length of the list `seen` is the desired answer.

This algorithm is correct but not efficient, because every round of the loop calls the operator `in`, which can take $$O(n)$$ time. Thus the time complexity of the algorithm is $$O(n^2)$$. However, a simple improvement is to use a set instead of a list.

Algoritmi käy läpi luvut ja lisää luvun listaan `seen`, jos lukua ei ole vielä listassa. Lopuksi listan `seen` koko on yhtä suuri kuin eri lukujen määrä.

Tämä algoritmi on toimiva mutta ei tehokas, koska jokaisella silmukan kierroksella vie aikaa $$O(n)$$ tarkastaa operaattorilla `in`, onko luku listassa. Tämän vuoksi algoritmin aikavaativuus on $$O(n^2)$$. Algoritmia on kuitenkin helppoa parantaa käyttämällä listan sijasta joukkoa.

**Efficient solution (set)**

We can solve the task efficiently using a set as follows:

Voimme ratkaista tehtävän tehokkaasti joukon avulla seuraavasti:

```python
def count_distinct(numbers):
    seen = set()
    for x in numbers:
        if x not in seen:
            seen.add(x)
    return len(seen)
```

This function almost identical to the preceding one; the only differences are defining `seen` as a set instead of a list and using the method `add` instead of `append`. This change has a big effect on the efficiency of the algorithm. After the change, the operator `in` takes only $$O(1)$$ time and thus the time complexity of the algorithm is $$O(n)$$.

We can simplify code further by using the fact that a set contains no duplicates. Thus we can remove the check if an element is already in the set:

Funktio on muuten samanlainen kuin aiemmassa listaratkaisussa, mutta `seen` on nyt joukko ja alkiot lisätään metodilla `add`. Tällä muutoksella on suuri vaikutus algoritmin tehokkuuteen. Muutoksen jälkeen operaattori `in` vie aikaa $$O(1)$$ ja algoritmin aikavaativuus on vain $$O(n)$$.

Koodia on mahdollista vielä tiivistää käyttämällä hyväksi sitä, että sama alkio ei mene useita kertoja joukkoon. Tämän ansiosta koodista voi poistaa tarkastuksen, onko alkio valmiiksi joukossa:

```python
def count_distinct(numbers):
    seen = set()
    for x in numbers:
        seen.add(x)
    return len(seen)
```

We can shorten the code further by creating the set directly from the list. Only one line is needed:

Itse asiassa koodia voi tiivistää vielä lisää luomalla joukon suoraan listan pohjalta. Funktion toteutukseen riittää loppujen lopuksi yksi rivi koodia:

```python
def count_distinct(numbers):
    return len(set(numbers))
```

## Dictionary

The Python data structure `dict` or dictionary is based on hashing and stores key-value pairs. The idea is that we can use the key to retrieve the associated value.

A dictionary can be seen as a generalization of a list: In a list, keys are the indices $$0 \dots n$$, while in a dictionary, keys can be arbitrary objects.

Adding, accessing and removing data using a key takes $$O(1)$$ time.

Pythonin tietorakenne `dict` eli sanakirja on hajautukseen perustuva tietorakenne, johon voidaan tallentaa avain-arvo-pareja. Ideana on, että avaimen perusteella voidaan hakea siihen liittyvä arvo.

Sanakirjaa voi ajatella listan yleistyksenä: listassa avaimet ovat indeksit $$0 \dots n-1$$, kun taas sanakirjassa avaimet voivat olla mitä tahansa alkioita. Tietoa voi lisätä, hakea ja poistaa tehokkaasti ajassa $$O(1)$$ avaimen perusteella.

### Example

The following code creates a dictionary `weights` where the keys are strings and the values are numbers.

Seuraava koodi luo sanakirjan `weights`, jossa avaimet ovat merkkijonoja ja arvot ovat lukuja.

```python
weights = {}

weights["apina"] = 100
weights["banaani"] = 1
weights["cembalo"] = 500
```

The same dictionary can also be created as follows: 

Yllä olevan sanakirjan voi luoda myös näin:

```python
weights = {"apina": 100, "banaani": 1, "cembalo": 500}
```

The values in a dictionary can be used in the same way as the elements of a list:

Sanakirjan arvoja voi käsitellä samaan tapaan kuin listan arvoja:

```python
print(weights["apina"]) # 100
weights["apina"] = 150
print(weights["apina"]) # 150
```

The operator `in` checks if a given key is in the dictionary:

Operaattori `in` tarkastaa, onko sanakirjassa tiettyä avainta:

```python
print("apina" in weights) # True
print("ananas" in weights) # False
```

The command `del` removes a key and the associated value from a dictionary:

Komento `del` poistaa avaimen ja siihen liittyvän arvon sanakirjasta:

```python
print(weights) # {'apina': 100, 'banaani': 1, 'cembalo': 500}
del weights["banaani"]
print(weights) # {'apina': 100, 'cembalo': 500}
```

### Using a dictionary

We will next take a look at three common ways to use a dictionary in algorithm design.

Seuraavassa on kolme tavallista sanakirjan käyttötarkoitusta algoritmien suunnittelussa:

**Has an element occured**

A dictionary can be used similarly to a set to keep track of elements that have been seen:

Sanakirjaa voi käyttää joukon kaltaisesti pitämään kirjaa esiintyneistä alkioista:

```python
seen = {}
for x in items:
    seen[x] = True
```

This code is approximately the same functionality as the following code:

Tämä koodi on toiminnaltaan suunnilleen sama kuin seuraava koodi:

```python
seen = set()
for x in items:
    seen.add(x)
```

Indeed, a set can be seen as a special case of a dictionary, where each key is associated with the value `True` (or any fixed value).

Voikin ajatella, että joukko on sanakirjan erikoistapaus, jossa jokaisella avaimella on arvona `True` (tai jokin muu sama arvo).

**Counting occurrences**

A common use of dictionaries is counting element occurrences:

Tavallinen sanakirjan käyttötarkoitus on laskea, montako kertaa mikäkin alkio on esiintynyt.

```python
count = {}
for x in items:
    if x not in count:
        count[x] = 0
    count[x] += 1
```

This code counts the number of occurrences of each element using the dictionary `count`. If the element is not yet in the dictionary, the code adds the element as a key with the initial count of zero as the associated value. Then the count is incremented by one for every occurrence of the element.

Koodi laskee esiintymiskerrat sanakirjan `count` avulla. Jos alkiota `x` ei ole vielä sanakirjassa, koodi asettaa sen esiintymiskertojen määräksi `0`. Tämän jälkeen koodi kasvattaa alkion `x` esiintymiskertoja yhdellä.

**Position of occurrence**

In some algorithms, it is useful to keep track of where each element has occurred.

Joissakin algoritmeissa on hyödyllistä pitää yllä tietoa siitä, missä kohdassa mikäkin alkio on esiintynyt.

```python
pos = {}
for i, x in enumerate(items):
    pos[x] = i
```

Here the dictionary `pos` stores the index of the most recent occurrence of each element. Using the function `enumerate`, the code iterates through the list so that in each round `i` is the index of an element and `x` is the element itself. 

Tässä sanakirjassa `pos` on kunkin alkion viimeisin esiintymiskohta listassa. Funktion `enumerate` avulla lista voidaan käydä läpi niin, että joka kierroksella `i` sisältää alkion indeksin ja `x` itse alkion.

## Example: Mode

{: .note-title }
Task
<div class="note" markdown="1">

You are given a list of numbers, and your task is to compute the _mode_, which is the most frequent number on the list. If the mode is not unique, you can choose any of the most frequent numbers.

For example, when the list is $$[1,2,3,2,2,3,2,2]$$, the desired answer is $$2$$.

Annettuna on lista lukuja ja tehtäväsi on selvittää listan _moodi_ eli yleisin luku. Jos moodi ei ole yksikäsitteinen, voit valita minkä tahansa yhtä yleisistä luvuista.

Esimerkiksi kun lista on $$[1,2,3,2,2,3,2,2]$$, haluttu vastaus on $$2$$.

</div>

We can solve the task efficiently by using a dictionary to count the number of occurrences:

Voimme ratkaista tehtävän tehokkaasti hajautuksen avulla luomalla sanakirjan, johon lasketaan jokaisen alkion esiintymiskertojen määrä:

```python
def find_mode(numbers):
    count = {}
    mode = numbers[0]

    for x in numbers:
        if x not in count:
            count[x] = 0
        count[x] += 1
        
        if count[x] > count[mode]:
            mode = x
 
    return mode
```

Here `count` is a dictionary that stores the occurrence count for each element, and the variable `mode` stores the mode among the elements seen so far. Initially, `mode` is the first number on the list, and it is updated whenever the just updated count of an element exceeds the count of the current mode. Since the dictionary operations take $$O(1)$$ time, the time complexity of the algorithm is $O(n)$$.

Here is another way to implement the algorithm:

Tässä `count` on sanakirja, johon lasketaan lukujen esiintymiskerrat, ja muuttuja `mode` sisältää moodin. Alussa `mode` on listan ensimmäinen luku ja muuttujaa päivitetään aina, kun viimeksi käsitelty luku on esiintynyt useammin kuin muuttujassa oleva luku. Koska sanakirjan operaatiot toimivat ajassa $$O(1)$$, algoritmin aikavaativuus on $$O(n)$$.

Tässä on vielä toinen tapa toteuttaa algoritmi:

```python
def find_mode(numbers):
    count = {}
    mode = (0, 0)

    for x in numbers:
        if x not in count:
            count[x] = 0
        count[x] += 1

        mode = max(mode, (count[x], x))

    return mode[1]
```

Now the variable `mode` is a pair, where the first element is the occurrence count of the mode and the second element is the mode itself. For example, the value  `(5, 2)` means that the number `2` has occurred `5` times.

The advantage of this implementation is that we can use the function `max` to update the mode. Here `max` uses the first element of the pair as the primary comparison key and the second element as a secondary comparison key. Since the first element is the occurrence count, the pair with the larger count gets chosen by `max`.

Notice that the two functions may operate differently when there are multiple choices for the mode. The first function chooses the mode that reaches the final count first. The second function chooses the mode with the largest value, since the value of the mode is used as a secondary comparison key.

Nyt muuttuja `mode` on pari, jonka ensimmäinen alkio on moodin esiintymiskerrat ja toinen alkio on itse moodi. Esimerkiksi jos muuttujan arvona on `(5, 2)`, tämä tarkoittaa, että alkio `2` on esiintynyt `5` kertaa.

Tämän toteutuksen etuna on, että moodia pystyy päivittämään `max`-funktion avulla. Tässä `max`-funktio vertailee ensisijaisesti parin ensimmäistä alkiota ja toissijaisesti parin toista alkiota. Koska parin ensimmäinen alkio on esiintymiskertojen määrä, parin arvo on sitä suurempi mitä useammin luku on esiintynyt.

Huomaa, että yllä olevat kaksi funktiota toimivat vähän eri tavalla tilanteessa, jossa on useita mahdollisia vaihtoehtoja moodiksi. Ensimmäinen funktio valitsee moodin, jonka viimeinen esiintymiskerta tulee vastaan ensimmäisenä. Toinen funktio puolestaan valitsee moodin, joka on arvoltaan suurin, koska pareissa vertaillaan toissijaisesti luvun suuruutta.

## Example: Rounds

{: .note-title }
Task
<div class="note" markdown="1">

You are given a list that contains the numbers $$1,2,\dots,n$$ in some order. Your taks is to collect all the numbers in order from smallest to largest so that in each round you go through the list from left to right. How many rounds do you need?

For example, the list is $$[3,6,1,7,5,2,4,8]$$ requires $$4$$ rounds. The first round collect the numbers $$1$$ and $$2$$, the second round the numbers $$3$$ and $$4$$, the third round the number $$5$$, and the fourth round the numbers $$6$$, $$7$$ and $$8$$. 

Annettuna on lista, joka sisältää luvut $$1,2,\dots,n$$ jossakin järjestyksessä. Tehtäväsi on kerätä luvut pienimmästä suurimpaan niin, että joka kierroksella käyt läpi listan vasemmalta oikealle. Montako kierrosta tarvitaan?

Esimerkiksi kun lista on $$[3,6,1,7,5,2,4,8]$$, lukujen keräämiseen tarvitaan $$4$$ kierrosta. Ensimmäinen kierros kerää luvut $$1$$ ja $$2$$, toinen kierros luvut $$3$$ ja $$4$$, kolmas kierros luvun $$5$$ ja neljäs kierros luvut $$6$$, $$7$$ ja $$8$$.
</div>

A useful observation is that a new round starts whenever the number to be collected next is to the left of the most recently collected number. In the example list above, $$3$$ starts a new round because it is to left of $$2$$.

Oleellinen havainto on, että uusi kierros täytyy aloittaa aina silloin, kun kerättävä luku on edellisen kerätyn luvun vasemmalla puolella. Esimerkiksi yllä olevassa listassa luku $$3$$ aloittaa uuden kierroksen, koska se on luvun $$2$$ vasemmalla puolella.

**Slow solution (list)**

The following algorithm solves the task using a list:

Seuraava algoritmi ratkaisee tehtävän käyttäen vain listaa:

```python
def count_rounds(numbers):
    n = len(numbers)
    
    rounds = 1
    for i in range(1, n):
        if numbers.index(i + 1) < numbers.index(i):
            rounds += 1
            
    return rounds
```

Here the number of rounds is computed into the variable `rounds`, which is initially set to 1. Then the loop goes through the numbers $$1 \dots n-1$ and increments `rounds` whenever the number $$i+1$$ occurs to the left of the number $$i$$. 

The implementation uses the method `index` to locate the occurrence of a number. This makes the algorithm slow, because the method `index` needs $$O(n)$$ time and thus the total time complexity of the algorithm is $$O(n^2)$$.

Ideana on laskea muuttujaan `rounds` tarvittava kierrosten määrä. Alussa kierrosten määrä on yksi. Sitten silmukka käy läpi luvut $$1 \dots n-1$$ ja lisää kierrosten määrää yhdellä aina, kun luku $$i+1$$ esiintyy listassa ennen lukua $$i$$.

Tässä toteutuksessa on käytössä listan metodi `index`, joka antaa luvun sijainnin listassa. Tämän takia algoritmi on kuitenkin hidas, koska metodi `index` vie aikaa $$O(n)$$ ja koko algoritmin aikavaativuus on $$O(n^2)$$.

**Efficient solution (dictionary)**

We can implement the same idea efficiently by using a dictionary to locate each number:

Voimme toteuttaa saman idean tehokkaasti ottamalla käyttöön sanakirjan, joka sisältää kunkin luvun kohdan listassa:

```python
def count_rounds(numbers):
    n = len(numbers)
    
    pos = {}
    for i, x in enumerate(numbers):
        pos[x] = i
        
    rounds = 1
    for i in range(1, n):
        if pos[i + 1] < pos[i]:
            rounds += 1

    return rounds
```

Now locating a number needs only $$O(1)$$ time. Since the algorithm has two separate loops, each of which needs $$O(n)$$ time, the total time complexity of the algorithm is $$O(n)$$.

Tämän jälkeen ei tarvitse käyttää metodia `index` vaan luvun sijainnin listasta saa haettua tehokkaasti sanakirjasta. Algoritmissa on kaksi silmukkaa, jotka toimivat molemmat ajassa $$O(n)$$, joten koko algoritmin aikavaativuus on $$O(n)$$.

## Example: Play list

{: .note-title }
Task
<div class="note" markdown="1">

You are given a play list, where each song is represented by an integer. Your task to find out how long is the longest part of the play list that contains no song twice.

For example, when the play list is $$[1,2,1,3,5,4,3,1]$$, the desired answer is $$5$$, which is the length of the play list part $$[2,1,3,5,4]$$.

Annettuna on soittolista, jossa jokaista laulua vastaa tietty kokonaisluku. Tehtäväsi on selvittää, miten pitkä on pisin soittolistan osa, jossa ei esiinny kahta samaa laulua.

Esimerkiksi kun soittolista on $$[1,2,1,3,5,4,3,1]$$, haluttu vastaus on $$5$$. Tämä vastaa soittolistan osaa $$[2,1,3,5,4]$$.

</div>

A good approach to this task compute, for each position in the play list, how long is the longest non-repeating part ending at that position. The maximum of those lengths is the final answer. With the above example play list, these lengths are:

Hyvä lähestymistapa tähän tehtävään on laskea jokaiseen soittolistan kohtaan, kuinka pitkä on pisin kyseiseen kohtaan päättyvä soittolistan osa, jossa ei esiinny kahta samaa laulua. Näistä pituuksista suurin on tehtävän haluttu vastaus. Äskeisessä esimerkissä nämä pituudet ovat:

Song | 1 | 2 | 1 | 3 | 5 | 4 | 3 | 1
Length | 1 | 2 | 2 | 3 | 4 | 5 | 3 | 4

When we are at a given position in the play list and encounter a song that has occurred earlier, this may reduce the length of the non-repeating part, since any earlier occurrence of the song may not appear on the part. Thus the non-repeating part can start only after the nearest earlier occurrence. Using this principle, we can figure out the earliest possible start for the non-repeating part.

The following efficient algorithm implements these ideas:

Kun olemme tietyssä soittolistan kohdassa ja vastaan tulee aiemmin listalla esiintynyt laulu, tämä rajoittaa soittolistan osan pituutta, koska kyseinen laulu ei saa esiintyä kahta kertaa. Niinpä soittolistan osan tulee alkaa laulun edellisen esiintymän jälkeen. Tämän avulla voimme päätellä, mistä kohdasta soittolistan osa voi alkaa.

Seuraava tehokas algoritmi perustuu yllä oleviin ideoihin:

```python
def max_length(songs):
    n = len(songs)
    
    pos = {}
    start = 0
    length = 0
    
    for i, song in enumerate(songs):
        if song in pos:
            start = max(start, pos[song] + 1)
        length = max(length, i - start + 1)
        pos[song] = i
        
    return length
```

The dictionary `pos` stores the position of the last occurrence of each song. The variable 'start` keeps track of the earliest possible starting position of a non-repeating part ending at the current position, and the variable `length` is the length of the longest non-repeating play list part we have found so far.

The algorithm goes through the play list and updates `start` whenever it encounters a song that it has seen before. In such a case, the value of `start` can increase to avoid a repeat of the song.

The time complexity of the algorithm is $$O(n)$$ thanks to the efficient dictionary operations based on hashing.

Sanakirja `pos` kertoo kustakin laulusta, missä kohtaa soittolistaa laulu on esiintynyt viimeksi. Muuttujassa `start` on kohta, josta soittolistan osa voi alkaa, ja muuttujassa `length` on pisin soittolistan osan pituus.

Algoritmi käy läpi soittolistan ja päivittää muuttujaa `start` aina, kun vastaan tulee laulu, joka on esiintynyt aiemmin soittolistalla. Tässä tilanteessa muuttujan `start` arvo kasvaa, jos laulun edellisen esiintymän kohta on aiempaa suurempi.

Tuloksena oleva algoritmi toimii ajassa $$O(n)$$ hajautuksen ansiosta.

## Example: List sums

{: .note-title }
Task
<div class="note" markdown="1">

You are given a list containing $n$ integers. Your task is to count, how many sublists of the list have $$x$$ as the sum of its elements.

For example, when the list is $$[2,3,5,-3,4,4,6,2]$$ and $$x=5$$, te desired answer is $$4$$. The sublists with sum $$x$$ are $$[2,3]$$, $$[5]$$, $$[3,5,-3]$$ and $$[-3,4,4]$$.

Annettuna on lista, jossa on $$n$$ kokonaislukua. Tehtäväsi on laskea, monessako listan osalistassa lukujen summa on $$x$$.

Esimerkiksi kun lista on $$[2,3,5,-3,4,4,6,2]$$ ja $$x=5$$, haluttu vastaus on $$4$$. Tässä tapauksessa osalistat ovat $$[2,3]$$, $$[5]$$, $$[3,5,-3]$$ ja $$[-3,4,4]$$.

</div>

A useful technique in this kind of a task is to consider prefix sums of the list, i.e., to compute for each position the sum of the numbers from the beginning of the list to that position. In our example list, the prefix sums are as follows:

Hyödyllinen tekniikka tällaisessa tehtävässä on tarkastella listan alkuosien lukujen summia eli laskea jokaiseen kohtaan lukujen summa listan alusta kyseiseen kohtaan. Esimerkissä alkuosien summat ovat seuraavat:

Index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
Number | 2 | 3 | 5 | –3 | 4 | 4 | 6 | 2
Prefix sum | 2 | 5 | 10 | 7 | 11 | 15 | 21 | 23

For example, the prefix sum at the position $$4$$ is $$11$, because the numbers from the position $$0$$ to the position $$4$$ sum up to $$2+3+5-3+4=11$$.

Esimerkiksi kohdassa $$4$$ alkuosan summa on $$11$$, koska listan lukujen summa kohdasta $$0$$ kohtaan $$4$$ on $$2+3+5-3+4=11$$.

With the prefix sums, any sublist sum can be computed efficiently as a difference of two prefix sums. If a sublist starts at the position $$a$$ and ends at the position $$b$$, the sublist sum is obtained by subtracting the prefix sum at the position $$a-1$$ from the prefix sum at the position $$b$$.

In our example, the sublist that starts at the position $$2$$ and ends at the position $$4$$ has the sublist sum $$5-3+2=6$$. With the prefix sums, we can equivalently compute the sublist sum as the difference $$11-5=6$$.

The following algorithm is based on this technique:

Alkuosien summien hyötynä on, että minkä tahansa osalistan lukujen summa saadaan laskettua kahden alkuosan summan perusteella. Kun osalista alkaa kohdasta $$a$$ ja päättyy kohtaan $$b$$, sen lukujen summa saadaan laskemalla alkuosan summa kohtaan $$b$$ ja vähentämällä siitä alkuosan summa kohtaan $$a-1$$.

Esimerkiksi kun osalista alkaa kohdasta $$2$$ ja päättyy kohtaan $$4$$, sen lukujen summa on $$5-3+4=6$$. Tämä on yhtä suuri kuin alkuosan summa kohtaan $$4$$, josta on vähennetty alkuosan summa kohtaan $$1$$, eli $$11-5=6$$.

Oletetaan nyt, että olemme listan kohdassa $$i$$ ja haluamme laskea, monessako kohtaan $$i$$ päättyvässä osalistassa lukujen summa on $$x$$. Kun alkuosan summa kohdassa $$i$$ on $$p$$, alkuosan summan tulee olla $$p-x$$ aiemmassa kohdassa, jotta osalistan summaksi tulee $$p-(p-x)=x$$. Niinpä haluttuja osalistoja on yhtä monta kun aiempia kohtia, joissa alkuosan summa on $$p-x$$.

Seuraava algoritmi perustuu yllä olevaan ideaan:

```python
def count_sublists(numbers, x):
    count = {0: 1}
    prefix_sum = 0
    result = 0
    
    for i in range(len(numbers)):
        prefix_sum += numbers[i]
        if prefix_sum - x in count:
            result += count[prefix_sum - x]
        
        if prefix_sum not in count:
            count[prefix_sum] = 0
        count[prefix_sum] += 1
        
    return result    
```

Here the dictionary `count` is used for storing, how many times each prefix sum has occured. With the dictionary, we can efficiently find out how many earlier prefix sums match the current prefix sum so that the difference is exactly $$x$$. The dictionary is initialized with the prefix sum $$0$$ corresponding to the empty prefix list to account for the sublists starting at the beginning of the list.

The time complexity of the resulting algorithm is $$O(n)$$.

Tässä sanakirjaan `count` lasketaan, montako kertaa mikäkin summa on esiintynyt listan alkuosien summissa. Sanakirjan avulla voidaan laskea tehokkaasti jokaiseen listaan kohtaan, monessako kyseiseen kohtaan päättyvässä osalistassa summa on $$x$$. Sanakirjassa on valmiina tyhjää listaa tarkoittava summa $$0$$, jotta algoritmi laskee oikein myös tapaukset, joissa osalista alkaa listan alusta.

Tuloksena oleva algoritmi toimii ajassa $$O(n)$$ hajautuksen ansiosta.

## How does hashing work?

The Python data structures of this chapter, `set` and `dict`, are based on hashing and a data structure called [hash table](../hajautustaulu). In python, a hash table is implemented using open hashing.

Python has a built-in function `hash` that can be used for computing a hash value for an object. Python calls this function to determine the location of the object in a hash table. The function can be tested as follows:

Tässä luvussa esitellyt Pythonin tietorakenteet `set` ja `dict` perustuvat hajautukseen ja niiden taustalla on tietorakenne [hajautustaulu](../hajautustaulu). Pythonissa hajautustaulu on toteuttu avointa hajautusta käyttäen.

Pythonissa on sisäänrakennettu funktio `hash`, jolla voidaan laskea alkion hajautusarvo. Python kutsuu tätä funktiota, kun se määrittää alkion sijainnin hajautustaulussa. Funktion toimintaa voi testata näin:

```console?lang=python
> hash(42)
42
> hash(10**100)
910685213754167845
> hash("apina")
4992529190565255982
```

As the above shows, in Python, the hash value of a small integer is the integer itself. Otherwise, the hash values are random looking numbers.

The Python data structures based on hahsing are usually efficient, and you can assume that an addition, access or removal takes $$O(1)$$ time. However, there is a possiblity that hashing is slow if the input chosen in a [specific way](../hajautus-hitaus).

Kuten yllä olevasta testistä voi havaita, Pythonissa pienen kokonaisluvun hajautusarvo on suoraan kyseinen luku. Muuten hajautusarvot ovat yleensä satunnaisen näköisiä lukuja.

Pythonissa hajautusta käyttävät tietorakenteet toimivat yleensä aina tehokkaasti ja voidaan olettaa, että lisäykset, haut ja poistot vievät aikaa $$O(1)$$. Silti on mahdollista, että Pythonin hajautus toimii hitaasti, jos syöte on valittu [sopivalla tavalla](../hajautus-hitaus).

### Which objects can be hashed?

The following code does not work in Python:

Seuraava koodi ei toimi Pythonissa:

```python
lists = set()
lists.add([1, 2, 3]) # TypeError: unhashable type: 'list'
```

The problem is that it is not possible to compute a has value for a list.

Ongelmana on, että listalle ei voi laskea hajautusarvoa:

```python
print(hash([1, 2, 3])) # TypeError: unhashable type: 'list'
```

A basic principle in Python is that a hash value can be computed only for an _immutable_ objects. A list is not immutable, because we can change the list with operations like `append`, and thus hashing lists is not possible.

Immutable objects in Python include numbers, strings and tuples consisting of immutable objects. For example, the following code works, because a tuple of numbers is immutable.

Pythonissa on periaatteena, että hajautusarvon voi laskea vain oliolle, jonka sisältö on _muuttumaton_ (_immutable_). Listan sisältö ei ole muuttumaton, koska listassa on esimerkiksi metodi `append`, joka lisää siihen uuden alkion. Tämän vuoksi listalle ei voi laskea hajautusarvoa.

Muuttumattomia olioita ovat esimerkiksi luvut, merkkijonot ja näitä sisältävät tuplet. Esimerkiksi seuraava koodi toimii, koska lukuja sisältävä tuple on muuttumaton ja sille voidaan laskea hajautusarvo:

```python
lists = set()
lists.add((1, 2, 3))
```

Notice that in a dictionary the hash value is computed only for the key and the associated value does not need to be hashable. An example of this is the following code with a string as a key and a list as a value:

Huomaa, että sanakirjassa vain avaimelle lasketaan hajautusarvo. Tämän takia myös seuraava koodi toimii, jossa avain on merkkijono ja arvo on lista:

```python
lists = {}
lists["apina"] = [1, 2, 3]
```

### Hashing for your own class

If you define your own class, you can apply hashing to it by defining the following methods:

Omaa luokkaa voi käyttää hajautuksessa määrittelemällä sille seuraavat metodit:

* `__hash__`: palauttaa olion hajautusarvon (funktio `hash` kutsuu sitä)
* `__eq__`: vertailee, onko olion sisältö sama kuin toisen olion sisältö (operaattori `==` kutsuu sitä)

The following shows an example of defining these methods. Here the method '__hash__` returns the hash value of a tuple representing the contents of the object.

Seuraavassa on esimerkki metodien määrittelystä. Tässä metodi `__hash__` palauttaa olion sisältöä vastaavan tuplen hajautusarvon.

```python
class Location:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __hash__(self):
        return hash((self.x, self.y))

    def __eq__(self, other):
        return (self.x, self.y) == (other.x, other.y)
```

With this definition, the following code works as expected:

Tämän jälkeen esimerkiksi seuraava koodi toimii tarkoitetulla tavalla:

```python
locations = set()
locations.add(Location(1, 2))
locations.add(Location(3, -5))
locations.add(Location(1, 4))
```

## Hashing in other programming languages

Data structures based on hashing are available in many programming languages. Often the data structure corresponding to a Python dictionary is called a _map_.

In C++, the data structures `std::unordered_set` and `std::unordered_map` implement a set and a map using hashing.

Hajautusta käyttävät tietorakenteet ovat yleisiä eri ohjelmointikielissä. Monissa kielissä Pythonin sanakirjaa vastaa tietorakenne nimeltä _map_, josta voidaan käyttää suomeksi nimeä _hakemisto_.

C++:ssa tietorakenteet `std::unordered_set` ja `std::unordered_map` toteuttavat hajautusta käyttävän joukon ja hakemiston.

```cpp
std::unordered_set<int> numbers;

numbers.add(1);
numbers.add(2);
numbers.add(3);
```

```cpp
std::unordered_map<std::string, int> weights;

weights["apina"] = 100;
weights["banaani"] = 1;
weights["cembalo"] = 500;
```

In Java, the corresponding data structures are `HashSet` and `HashMap`:

Javassa vastaavat tietorakenteet ovat `HashSet` ja `HashMap`:

```java
HashSet<Integer> numbers = new HashSet<Integer>();

numbers.add(1);
numbers.add(2);
numbers.add(3);
```

```java
HashMap<String, Integer> weights = new HashMap<String, Integer>();

weights.put("apina", 100);
weights.put("banaani", 1);
weights.put("cembalo", 500);
```

And in JavaScript, the data structure `Set` implements a set:

JavaScriptissä tietorakenne `Set` toteuttaa joukon:

```js
let numbers = new Set();

numbers.add(1);
numbers.add(2);
numbers.add(3);
```

The traditional ways to create a map in JavaScript is to define an object:

JavaScriptin perinteinen tapa luoda hakemisto on määritellä olio:

```js
let weights = {};

weights["apina"] = 100;
weights["banaani"] = 1;
weights["cembalo"] = 500;
```

A newer way is to use a separate data structure `Map`:

Uudempi tapa on käyttää erillistä tietorakennetta `Map`:

```js
let weights = new Map();

weights.set("apina", 100);
weights.set("banaani", 1);
weights.set("cembalo", 500);
```
