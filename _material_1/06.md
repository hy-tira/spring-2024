---
title: 6. Own data structures
slug: osa6
hide: true
sections:
  - "Example: Stack"
  - How not to implement a class
  - Additional class features
  - "Example: Efficient duplicates"
  - "Example: Mode"
---

# 6. Own data structures

The functionality of a data structure can be represented as a collection of methods, each with given parameters and a given result from calling it. For example, the Python list has the methods `append`, `count` and `index` that add an element to the list, count the number of occurrences of an element and search for the index of an element.

By defining a class we can implement a customized data structure that has its own set of methods. Often such a data structure contains some standard Python data structure such as a list or a dictionary. The advantage of a class is that offers a clean interface that hides the details of the internal implementation.

Tietorakenteen toiminta voidaan esittää joukkona metodeita, joilla on tietyt parametrit ja joiden kutsuminen antaa tietyn tuloksen. Esimerkiksi Pythonin listassa on metodit `append`, `count` ja `index`, joiden avulla pystyy lisäämään alkion listaan, laskemaan alkion esiintymiskerrat sekä etsimään alkion indeksin.

Luokkien avulla voimme toteuttaa itse tietorakenteita, jotka sisältävät haluttuja metodeja. Usein tällaisen luokan sisällä on jokin Pythonin tietorakenne, kuten lista tai sanakirja. Luokan etuna on, että se tarjoaa tietorakenteelle siistin rajapinnan, jonka takana on tietorakenteen sisäinen toteutus.

## Example: Stack

{: .note-title }
Task
<div class="note" markdown="1">

Implement a class `Stack` that implements the stack data structure. The class should have the following methods:

* `push(x)`: add the element `x` to the top of the stack
* `top()`: access the element at the top of the stack
* `pop(): remove the element at the top of the stack

The time complexity of each method should be $$O(1)$$.

Toteuta luokka `Stack`, joka toteuttaa pinotietorakenteen. Luokassa tulee olla seuraavat metodit:

* `push(x)`: lisää alkio `x` pinon ylimmäksi
* `top()`: hae pinon ylin alkio
* `pop()`: poista pinon ylin alkio

Jokaisen metodin aikavaativuuden tulee olla $$O(1)$$.

</div>

The class `Stack` is easy to implement using the Python list, which supports additions and removals at the end of the list in $$O(1)$$ time. We can implement the class as follows:

Luokka `Stack` on helppoa toteuttaa Pythonin listan avulla, koska alkion lisääminen listan loppuun ja poistaminen listan lopusta toimivat ajassa $$O(1)$$. Voimme toteuttaa luokan seuraavasti:

```python
class Stack:
    def __init__(self):
        self.stack = []

    def push(self, x):
        self.stack.append(x)

    def top(self):
        return self.stack[-1]

    def pop(self):
        self.stack.pop()
```

The idea is that the class defines an internal list `stack` that stores the elements of the stack. The methods `push` and `pop` are implemented using the list methods `append` and `pop`, and the method `top` is implemented by accessing the last element of the list.

The following code tests the functionality of the class:

Ideana on, että luokan sisällä määritellään lista `stack`, johon tallennetaan pinon alkiot. Metodit `push` ja `pop` toteutetaan listan metodien `append` ja `pop` avulla ja metodi `top` toteutetaan hakemalla listan viimeinen alkio.

Seuraava koodi testaa luokan toimintaa:

```python
s = Stack()
s.push(1)
s.push(2)
s.push(3)
print(s.top()) # 3
print(s.top()) # 3
s.pop()
print(s.top()) # 2
```

Using the class `Stack` instead of using the list directly restricts the functionality to the stack methods. For example, access is restricted to the last element of the list. The user of the class does not need to know the internal implementation, but can trust that the methods `push`, `top` and `pop` are available.

Notice that we can access the internal data too if we know how the class is implemented. This is illustrated by the following code:

Tässä tapauksessa luokka `Stack` rajoittaa listan toimintaa, koska luokan metodeilla on mahdollista käsitellä vain listan viimeistä alkiota. Luokan käyttäjän ei tarvitse tietää, miten luokka on toteutettu sisäisesti, vaan hän voi luottaa siihen, että saatavilla on metodit `push`, `top` ja `pop`.

Huomaa, että voimme kuitenkin käsitellä luokan sisäistä tietoa, jos tiedämme, miten luokka on toteutettu. Seuraava koodi havainnollistaa asiaa:

```python
s = Stack()
s.push(1)
s.push(2)
s.push(3)
print(s.stack) # [1, 2, 3]
```

Here the print command accesses all elements of the internal list, even though only the last element is accessible through the class methods.

Luokka tallentaa sisäisesti pinon sisällön listaan `stack`, jonka sisältöön pääsee käsiksi, vaikka luokan metodeilla voi käsitellä vain pinon ylintä alkiota.

## How not to implement a class

The following way of implementing a class does not work:

Seuraava tapa luokan toteuttamiseen ei ole toimiva:

```python
class Stack:
    stack = []

    def push(self, x):
        self.stack.append(x)

    def top(self):
        return self.stack[-1]

    def pop(self):
        self.stack.pop()
```

The difference to the earlier class is that now there is no constructor (method `__init__`) and the list `stack` is created at the main level of the class. This can appear to work at first try:

Erona aiempaan luokkaan tässä luokassa ei ole alustusmetodia `__init__` vaan lista `stack` luodaan luokan päätasolla. Päältä päin luokka vaikuttaa toimivalta:

```python
s = Stack()
s.push(1)
s.push(2)
s.push(3)
print(s.top()) # 3
```

The trouble is that the list `stack` is _shared_ by all objects created from the class. This is illustrated by the following code:

Ongelmana tässä toteutuksessa on kuitenkin, että lista `stack` on _yhteinen_ kaikille luokasta luoduille olioille. Seuraava koodi havainnollistaa ongelmaa:

```python
a = Stack()
b = Stack()
a.push(1)
b.push(2)
print(a.top()) # 2
```

The code adds the number `1` to the stack `a` and the number `2` to the stack `b`. Then the code accesses the top element of the stack `a`. The result should be `1` but here it is `2` because of the shared list `stack`. Adding an element to one stack adds it to both stacks, which is not how the class should function.

Koodi lisää pinoon `a` luvun `1` ja pinoon `b` luvun `2`. Tämän jälkeen koodi hakee pinon `a` ylimmän alkion. Tuloksen pitäisi olla `1`, mutta se onkin `2`, koska pinoilla on yhteinen lista `stack`. Tämän seurauksena alkion lisääminen toiseen pinoon lisää sen kumpaankin pinoon eikä luokka toimi halutulla tavalla.

## Additional class features

The earlier class `Stack` is correct but is still missing some useful features. First, the printout of a stack is not very informative:

Aiempi luokka `Stack` toimii sinänsä, mutta siinä on vielä joitakin puutteita. Ensinnäkään pinon sisällön tulostaminen ei anna hyödyllistä tietoa:

```python
s = Stack()
s.push(1)
s.push(2)
s.push(3)
print(s) # <__main__.Stack object at 0x7fd6c4e23ee0>
```

We can address this by adding a method `__repr__` that produces a description of the contents of the stack as a string. In this case, the method can turn the list `stack` into a string and return that:

Voimme korjata tämän lisäämällä luokkaan metodin `__repr__`, jonka tehtävänä on palauttaa tekstimuotoinen esitys luokan sisällöstä. Voimme toteuttaa metodin niin, että se palauttaa suoraan listan `stack` sisällön tekstinä:

```python
    def __repr__(self):
        return str(self.stack)
```

After this change, we can print out the contents of a stack:

Tämän muutoksen jälkeen pinon sisältö tulostuu näin:

```python
s = Stack()
s.push(1)
s.push(2)
s.push(3)
print(s) # [1, 2, 3]
```

Another feature missing is that we cannot determine the size of the stack with the function `len`. Trying to do that would cause an error. We can fix this by defining the method `__len__`:

Toinen puute on, että pinon kokoa ei pysty selvittämään funktiolla `len`, vaan tämä aiheuttaa virheilmoituksen. Voimme korjata tämän lisäämällä luokkaan seuraavan metodin `__len__`:

```python
    def __len__(self):
        return len(self.stack)
```

The method `__len__` is called when an object of the class is given as parameter to the function `len`. With our class, the method can return the length of the internal list `stack`. Now the following code works as expected:

Metodia `__len__` kutsutaan silloin, kun luokasta tehty olio annetaan funktion `len` parametriksi. Tässä tapauksessa metodin riittää palauttaa listan `stack` koko. Nyt seuraava koodi toimii järkevällä tavalla:

```python
s = Stack()
s.push(1)
s.push(2)
s.push(3)
print(len(s)) # 3
```

There is still a potential problem with the methods `pop` and `top`. What happens if the list is empty when they are called? In such a situation, there is no element to remove or access. We can add error handling to the methods to cover such situations as follows:

Metodeissa `pop` ja `top` on vielä puutteena, että ne eivät ota huomioon tilannetta, jossa pino on tyhjä. Tässä tilanteessa ei ole mahdollista poistaa tai hakea pinon ylintä alkiota. Voimme lisätä metodeihin virheenkäsittelyn seuraavasti:

```python
    def pop(self):
        if len(self.stack) == 0:
            raise IndexError("pop from empty stack")
        return self.stack.pop()

    def top(self):
        if len(self.stack) == 0:
            raise IndexError("top from empty stack")
        return self.stack[-1]
```

Now, if the methods are called when the stack is empty, they produce the error `IndexError` with a text describing the cause of the error. This is illustrated by the following code: 

Nyt jos metodeita kutsutaan pinon ollessa tyhjä, metodit tuottavat `IndexError`-virheen, jossa on tekstimuotoinen kuvaus virheen syystä. Seuraava koodi havainnollistaa asiaa:

```python
s = Stack()
s.push(1)
s.pop()
s.pop() # IndexError: pop from empty stack
```

## Example: Efficient duplicates

{: .note-title }
Task
<div class="note" markdown="1">

Implement a class 'SuperStack` with the following methods:

* `push(x)`: add the element `x` to the top of the stack
* `push_many(k, x)`: add `k` copies of the element `x` to the top of the stack
* `top()`: access the element at the top of the stack
* `pop(): remove the element at the top of the stack

The time complexity of each method should be $$O(1)$$.

Toteuta luokka `SuperStack`, jossa on seuraavat metodit:

* `push(x)`: lisää alkio `x` pinon ylimmäksi
* `push_many(k, x)`: lisää pinon ylimmäksi `k` kertaa alkio `x`
* `top()`: hae pinon ylin alkio
* `pop()`: poista pinon ylin alkio

Jokaisen metodin aikavaativuuden tulee olla $$O(1)$$.

</div>

This class `SuperStack` is the same as the earlier class `Stack` but with the addition of the method `push_many`, which adds multiple copies of the same element to the stack. The new method is a challenge, because it should run in $$O(1)$$ time independent of how many copies of the element is added.

The following straightforward implementation is not efficient enough:

Tämä luokka vasta muuten aiempaa luokkaa `Stack`, mutta siinä on uusi metodi `push_many`, jonka avulla voi lisätä saman alkion useita kertoja pinoon. Luokan toteutuksessa on haasteena, että myös metodin `push_many` tulee toimia ajassa $$O(1)$$ riippumatta siitä, miten monta kertaa alkio lisätään.

Seuraava tapa toteuttaa metodi `push_many` ei ole riittävä:

```python
    def push_many(self, x, k):
        for i in range(k):
            self.push(x)
```

Here the loop needs $$O(k)$$ time and its running time depends on the number of copies added. To achieve the time complexity $$O(1)$$, the method should have no loop.

A useful approach to class design is to separate what is required and how it is achieved. Here the class is required to have the four methods with time complexity $$O(1)$$, but we are free to choose the internal implementation. Specifically, there is no requirement to store each element separately in a stack as long as the methods work _as if_ there was such a stack.

An efficient way to implement the class is to store a stack of pairs of the form $$(k,x)$$, which represents $k$ copies of the element $$x$$. For example, the code 

Tässä ongelmana on, että metodissa on silmukka, joka vie aikaa $$O(k)$$, eli metodin suoritusaika riippuu siitä, montako kertaa alkio lisätään. Kuitenkin aikavaativuuden tulisi olla $$O(1)$$ eli metodissa ei saa olla silmukkaa.

Hyödyllinen näkökulma luokan suunnittelussa on, että luokan ainoa vaatimus on toteuttaa halutut operaatiot ajassa $$O(1)$$. Muilta osin voimme päättää vapaasti, millainen on luokan sisäinen toteutus. Erityisesti luokan ei ole pakko tallentaa jokaista alkiota erikseen pinoon, vaan sen riittää antaa _vaikutelma_ tällaisesta pinosta.

Tehokas tapa toteuttaa luokka on tallentaa pinoon sisäisesti pareja muotoa $$(k,x)$$: alkio $$x$$ esiintyy $$k$$ kertaa. Esimerkiksi koodi

```python
s = SuperStack()
s.push_many(3, 8)
s.push(4)
s.push_many(2, 5)
```

creates the stack $$[(3,8),(1,4),(2,5)]$$ as a compact representation of the stack $$[8,8,8,4,5,5]$$. Now each call to the methods `push` or `push_many` adds just one element to the compact stack. The methods `top` and `pop` have to be modified to correctly process the pairs in the stack. The class can be implemented as follows:

luo pinon $$[(3,8),(1,4),(2,5)]$$, joka esittää tiivistetyssä muodossa pinon $$[8,8,8,4,5,5]$$ sisällön. Tämän ansiosta jokainen metodin `push` tai `push_many` kutsu lisää vain yhden alkion pinoon. Vastaavasti metodit `top` ja `pop` täytyy toteuttaa niin, että ne käsittelevät oikealla tavalla pinossa olevia pareja. Luokka voidaan toteuttaa seuraavasti:

```python
class SuperStack:
    def __init__(self):
        self.stack = []
        
    def push(self, x):
        self.stack.append((1, x))
        
    def push_many(self, k, x):
        self.stack.append((k, x))
        
    def top(self):
        return self.stack[-1][1]
        
    def pop(self):
        last = self.stack[-1]
        if last[0] == 1:
            self.stack.pop()
        else
            self.stack[-1] = (last[0] - 1, last[1])
```

The method `top` returns the second element of the top pair, since that is the actual element in the stack. The method `pop` looks at the first element, the repeat count, of the top pair. If the repeat count is one, the whole pair is removed. Otherwise, the repeat count is reduced by one.

With this implementation, each method of the class runs in $$O(1)$$ time, since now there are no loops.

Metodi `top` palauttaa pinon ylimmän parin toisen jäsenen, koska jokaisen parin toinen jäsen vastaa pinossa olevaa alkiota. Metodi `pop` puolestaan tarkastelee pinon ylimmän parin ensimmäistä jäsentä eli toistokertojen määrää. Jos alkio toistuu kerran, metodi poistaa parin pinosta. Jos taas alkio toistuu useamman kerran, metodi vähentää toistokertojen määrää yhdellä.

Tämän toteutuksen ansiosta jokainen luokan metodi toimii ajassa $$O(1)$$, koska jokaisessa metodissa on kiinteä määrä komentoja eikä silmukoita.

## Example: Mode

{: .note-title }
Task
<div class="note" markdown="1">

Implement a class `Mode` with the following methods:

* `add(x)`: add the number `x` on the list
* `mode()`: return the mode of the list, i.e., the most frequent number on the list

The time complexity of each method should be $$O(1)$$.

Toteuta luokka `Mode`, jossa on seuraavat metodit:

* `add(x)`: lisää luku `x` listalle
* `mode()`: ilmoita listan moodi eli yleisin luku

Jokaisen metodin aikavaativuuden tulee olla $$O(1)$$.

</div>

This is similar to the earlier task of computing the mode of a given list. The difference is that now we can alternate additions to the list with queries for the mode among the current list contents. For example, the class could be used as follows: 

Tämä on muunnelma aiemmasta tehtävästä, jossa laskettavana oli annetun listan lukujen moodi. Erona on, että luokan `Mode` avulla voi vuorotellen lisätä lukuja listalle sekä kysyä, mikä on tähän mennessä lisättyjen lukujen moodi. Esimerkiksi luokkaa voidaan käyttää näin:

```python
m = Mode()
m.add(1)
m.add(1)
m.add(2)
print(m.mode()) # 1
m.add(2)
m.add(2)
print(m.mode()) # 2
```

Since the mode query is the only query that the class needs to answer, we do not need to keep the full list, but just enough information to be able to compute the mode. We can use a dictionary to store the occurrence count of each number. In addition, the class stores the current mode.

Koska ainoa luokalta kysyttävä asia on listan lukujen moodi, meidän ei tarvitse tallentaa muistiin listaa vaan vain tarvittavat tiedot moodin laskemiseen. Voimme toteuttaa luokan käyttäen sanakirjaa, johon on tallennettu jokaisen luvun esiintymiskertojen määrä. Lisäksi luokassa on muistissa tämänhetkinen moodi.

```python
class Mode:
    def __init__(self):
        self.count = {}
        self.status = (0, 0)
        
    def add(self, x):
        if x not in self.count:
            self.count[x] = 0
        self.count[x] += 1
        self.status = max(self.status, (self.count[x], x))
        
    def mode(self):
        return self.status[1]
```

Sanakirja `count` sisältää kunkin luvun esiintymiskerran, ja parissa `status` on tieto moodista muodossa $$(k,x)$$: moodi on luku $$x$$, joka esiintyy listassa $$k$$ kertaa. Kun listalle lisätään luku $$x$$, moodia päivitetään, jos luku $$x$$ on lisäämisen jälkeen listan moodi. Tämä onnistuu kätevästi `max`-funktion avulla, joka vertaa ensisijaisesti parin ensimmäistä jäsentä ja toissijaisesti toista jäsentä.

Luokan kummassakin metodissa on vain yksittäisiä komentoja, joten ne toimivat vaatimusten mukaisesti ajassa $$O(1)$$.
