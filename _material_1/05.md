---
title: 5. Sorting
slug: chap05
hide: true
sections:
  - Järjestäminen Pythonissa
  - "Esimerkki: Pienin ero"
  - Hajautus vs. järjestäminen
  - Lisää järjestämisestä
  - "Esimerkki: Ravintola"
  - Miten järjestäminen toimii?
  - Järjestäminen muissa kielissä
---

# 5. Sorting

_Sorting_ is a classical algorithmic problem where the goal is to reorder the elements according to their value. There are efficient algorithm for sorting in $$O(n \log n)$$ time. 

In this chapter, we will see how to do sorting in Python and how it can be utilized in implementing efficient algorithms. We will also take a look at some theory of sorting and some common sorting algorithms.

_Järjestäminen_ (_sorting_) on klassinen algoritmiikan ongelma, jossa tehtävänä on järjestää annetut alkiot suuruusjärjestykseen. Järjestämiseen on kehitetty tehokkaita algoritmeja, jotka toimivat ajassa $$O(n \log n)$$.

Tässä luvussa näemme, miten järjestämistä voi käyttää Pythonissa ja mitä hyötyä siitä voi olla tehokkaiden algoritmien toteuttamisessa. Tutustumme myös järjestämisen teoriaan ja muutamaan yleiseen järjestämisalgoritmiin.

## Sorting in Python

A Python list can be sorted with the method `sort`:

Pythonissa listan sisältö voidaan järjestää metodilla `sort`:

```python
numbers = [4, 2, 1, 2]
numbers.sort()
print(numbers) # [1, 2, 2, 4]
```

In addition, Python has the function `sorted` that returns a sorted list:

Pythonissa on myös funktio `sorted`, joka palauttaa listan järjestettynä:

```python
numbers = [4, 2, 1, 2]
print(sorted(numbers)) # [1, 2, 2, 4]
```

The difference between the two ways of sorting a list is that the method `sort` modifies the list while the function `sorted` creates a new list and leaves the original list unmodified.

The time complexity of both the method `sort` and the function `sorted` is $$O(n \log n)$$, allowing their use within efficient algorithms.

Näissä tavoissa erona on, että metodi `sort` muuttaa olemassa olevaa listaa, kun taas funktio `sorted` muodostaa uuden listan.

Metodi `sort` ja funktio `sorted` toimivat tehokkaasti ajassa $$O(n \log n)$$, minkä ansiosta niitä voidaan käyttää tehokkaiden algoritmien toteuttamisessa.

## Example: Smallest difference

{: .note-title }
Task
<div class="note" markdown="1">

You are given a list of numbers. What is the smallest difference between two elements?

For example, whe the list is $$[4,1,7,3,9]$$, the desired answer is $$1$$, because the smallest difference is between the numbers $$3$$ and $$4$$.

Annettuna on lista lukuja. Mikä on pienin ero kahden luvun välillä?

Esimerkiksi kun lista on $$[4,1,7,3,9]$$, haluttu vastaus on $$1$$, koska pienin ero on lukujen $$3$$ ja $$4$$ välillä.

</div>

In a sorted list, the smallest difference is always between two adjacent elements. Thus we can solve the problem efficiently by sorting the list and going through all pairs of adjacent elements. For example, sorting the list $$[4,1,7,3,9]$$ results the list $$[1,3,4,7,9]$$, where the elements $$3$$ and $$4$$ with the smallest difference are adjacent.

The following function `min_diff` implements the algorithm:

Järjestetyssä listassa pienin ero on aina kahden vierekkäisen luvun välillä. Niinpä voimme ratkaista tehtävän tehokkaasti järjestämällä listan ja käymällä läpi kaikki vierekkäin olevat luvut. Esimerkiksi lista $$[4,1,7,3,9]$$ on järjestettynä $$[1,3,4,7,9]$$, jolloin pienimmän eron tuottavat luvut $$3$$ ja $$4$$ ovat vierekkäin.

Seuraava funktio `min_diff` toteuttaa algoritmin:

```python
def min_diff(numbers):
    numbers = sorted(numbers)

    result = numbers[1] - numbers[0]
    for i in range(2, len(numbers)):
        result = min(result, numbers[i] - numbers[i - 1])
    
    return result
```

The algorithm first sorts the list using the function `sorted` and then determines the smallest difference of adjacent elements into the the variable `result`.

The sorting takes $$O(n \log n)$$ time and going through the list takes $$O(n)$$ time, which gives $$O(n \log n)$$ as the total time complexity of the algorithm.

Algoritmi järjestää ensin listan kutsumalla funktiota `sorted` ja selvittää sitten muuttujaan `result` pienimmän eron kahden vierekkäisen luvun välillä.

Listan järjestäminen vie aikaa $$O(n \log n)$$ ja vierekkäisten lukujen vertaileminen vie aikaa $$O(n)$$, joten algoritmin aikavaativuus on $$O(n \log n)$$.

### Avoiding side effects

Notice that we could have used the method `sort` instead of the function `sorted`:

Huomaa, että voisimme käyttää funktion alussa myös listan metodia `sort`:

```python
def min_diff(numbers):
    numbers.sort()
    ...
```

The trouble with this, however, is the side effect modifying the list, which affects the list outside the function `min_diff` too. The following code segments illustrate why this is undesirable:

Tässä olisi kuitenkin ongelmana, että funktio aiheuttaisi sivuvaikutuksen, koska parametrina annetun listan järjestäminen heijastuisi myös funktion `min_diff` kutsukohtaan. Tämä ei ole toivottava ilmiö, koska funktion ei pitäisi muuttaa listan sisältöä. Seuraavat koodit havainnollistavat asiaa:

{: .code-title }
Using `sort`
```python
numbers = [4, 1, 7, 3,9]
print(min_diff(numbers)) # 1
print(numbers) # [1, 3, 4, 7, 9]
```

{: .code-title }
Using `sorted`
```python
numbers = [4, 1, 7, 3,9]
print(min_diff(numbers)) # 1
print(numbers) # [4, 1, 7, 3,9]
```

When using the method `sort`, the ordering of the list changes, which may come as a surprise for someone who knows what the function `min_diff` does (returns the smallest difference) but not how it does it. It is better to avoid this side effect by using the function `sorted`.

Kun käytössä on metodi `sort`, funktion `min_diff` kutsuminen järjestää sivuvaikutuksena listan `numbers`. Kun käytössä on funktio `sorted`, lista `numbers` ei muutu, koska funktio `sorted` luo uuden järjestetyn listan. Niinpä parempi ratkaisu on toteuttaa funktio alkuperäisellä tavalla käyttäen funktiota `sorted`.

## Hashing vs. sorting

Many task have two possibilities for an efficient solution: hashing and sorting. Let us consider an example that we solved with hashing earlier:

Monessa tehtävässä on kaksi mahdollisuutta tehokkaan ratkaisun luomiseen: hajautus tai järjestäminen. Tarkastellaan esimerkkinä tehtävää, jonka ratkaisimme aiemmin hajautuksen avulla:

{: .note-title }
Task
<div class="note" markdown="1">

You are given a list of numbers. How many distinct numbers does it contain?

For example, when the list is $$[3,1,2,1,5,2,2,3]$$, the desired answer is $$4$$, because the distinct numbers are $$1$$, $$2$$, $$3$$ and $$5$$.

Annettuna on lista lukuja. Montako eri lukua listalla on?

Esimerkiksi kun lista on $$[3,1,2,1,5,2,2,3]$$, haluttu vastaus on $$4$$, koska eri luvut ovat $$1$$, $$2$$, $$3$$ ja $$5$$.

</div>

Here is the earlier solution using hashing:

Ratkaisimme tehtävän aiemmin hajautuksen avulla näin:

{: .code-title }
Algoritmi 1
```python
def count_distinct(numbers):
    seen = set()

    for x in numbers:
        seen.add(x)

    return len(seen)
```

An alternative solution uses sorting. Since equal numbers are contiguous in a sorted list, we can go through the sorted list and increment a counter whenever the number changes.

Here is the algorithm that uses sorting:

Voimme ratkaista tehtävän myös toisella tavalla järjestämisen avulla. Koska järjestetyssä listassa yhtä suuret luvut ovat peräkkäin, voimme käydä järjestetyn listan läpi ja kasvattaa laskuria aina luvun vaihtuessa.

Tässä on järjestämistä käyttävä algoritmi:

{: .code-title }
Algoritmi 2
```python
def count_distinct(numbers):
    numbers = sorted(numbers)
   
    result = 1
    for i in range(1, len(numbers)):
        if numbers[i] != numbers[i - 1]:
            result += 1

    return result
```

The time complexity is $$O(n)$$ when using hashing and $$O(n \log n)$$ when using sorting, but how fast are they in practice?

Let us do a comparison test. Since both algorithms are efficient, we can use large test inputs ($$n=10^7$$). The input list contains random numbers in the range $$1 \dots k$, where $k$ varies. By varying the value of $k$, we can control how many of the numbers are equal, which might affect the running time.

Here are the test results for the test computer:

Hajautusta käyttävä algoritmi vie aikaa $$O(n)$$ ja järjestämistä käyttävä algoritmi vie aikaa $$O(n \log n)$$, mutta miten nopeita algoritmit ovat käytännössä?

Tehdään testi, joka vertailee algoritmien tehokkuutta. Koska molemmat algoritmit ovat tehokkaita, toteutetaan testi niin, että listan koko on aina suuri ($$n=10^7$$). Koska listalla olevien lukujen suuruus saattaa vaikuttaa algoritmin tehokkuuteen, lisätään listalle satunnaisia lukuja väliltä $$1 \dots k$$, missä $$k$$ vaihtelee. Tämän avulla voidaan tutkia, miten lukujen suuruus vaikuttaa tehokkuuteen.

Testikoneella tulokset ovat seuraavat:

| Luvun yläraja $$k$$ | Algoritmi 1 (hajautus) | Algoritmi 2 (järjestäminen)
| --- | --- | --- | 
| $$10^3$$ | 0.46 s | 3.18 s |
| $$10^4$$ | 0.56 s | 4.50 s |
| $$10^5$$ | 1.16 s | 5.74 s |
| $$10^6$$ | 2.56 s | 6.38 s |
| $$10^7$$ | 2.56 s | 6.48 s |

In this case, the algorithm using hashing appears to be more efficient. It is also slightly sorter and simpler.

Tässä tapauksessa vaikuttaa, että hajautusta käyttävä algoritmi on tehokkaampi. Se on myös koodiltaan yksinkertaisempi, koska silmukassa riittää lisätä listan luvut `set`-rakenteeseen eikä vertailla vierekkäisiä lukuja keskenään.

## More about sorting

### Sorting into reverse order

The parameter `reverse` changes the ordering from ascending to descending:

Parametri `reverse` muuttaa järjestämisen suunnan käänteiseksi:

```python
numbers = [2, 4, 3, 5, 6, 1, 8, 7]
numbers.sort(reverse=True)
print(numbers) # [8, 7, 6, 5, 4, 3, 2, 1]
```

### Multipart elements

If the elements to be sorted are tuples or lists, the first element of the tuple or list is the primary sorting key, the second element is the secondary key, etc..

For example, a list of pairs gets sorted as follows:

Jos järjestettävät alkiot ovat tupleja tai listoja, järjestys on ensisijaisesti ensimmäisen alkion mukaan, toissijaisesti toisen alkion mukaan, jne.

Esimerkiksi listassa olevat parit järjestyvät näin:

```python
pairs = [(3, 5), (1, 3), (1, 2), (2, 4)]
pairs.sort()
print(pairs) # [(1, 2), (1, 3), (2, 4), (3, 5)]
```

### Element comparisons

The parameter `key` can be used to define a function that is applied to each element before any order comparison. Below is an example of using the parameter:

Parametrilla `key` voidaan määritellä funktio, joka muuttaa alkioita ennen kuin niitä vertaillaan toisiinsa. Parametria voidaan käyttää esimerkiksi näin:

```python
numbers = [4, -1, 6, 2, -7, 8, 3, -5]
numbers.sort(key=abs)
print(numbers) # [-1, 2, 3, 4, -5, 6, -7, 8]
```

Here the function is `abs` (abstract value), which causes the sorting to ignore the minus sign.

Tässä funktiona on `abs` eli itseisarvo, minkä seurauksena luvut järjestetään suuruuden mukaan välittämättä niiden etumerkistä.

### Own class

In Python, objects of a class can be sorted, if the class defines sufficient methods for comparing objects. For example, it is enough to define the methods `__eq__` and `__lt__`, which are used when the objects are compared with the operators `==` and `<`. The following code illustrates this:

Pythonissa luokan olioita voidaan järjestää, kun luokkaan on toteutettu riittävästi metodeita olioiden vertailua varten. Esimerkiksi riittää, että on toteutettu metodit `__eq__` ja `__lt__`, jolloin olioita voidaan vertailla operaattoreiden `==` ja `<` avulla. Seuraava koodi havainnollistaa asiaa:

```python
class Location:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return (self.x, self.y) == (other.x, other.y)

    def __lt__(self, other):
        return (self.x, self.y) < (other.x, other.y)

    def __repr__(self):
        return str((self.x, self.y))

locations = []
locations.append(Location(1, 4))
locations.append(Location(4, 5))
locations.append(Location(2, 2))
locations.append(Location(1, 2))

locations.sort()

print(locations) # [(1, 2), (1, 4), (2, 2), (4, 5)]
```

## Example: Restaurant

{: .note-title }
Task
<div class="note" markdown="1">

A restaurant is visited by $n$ customers during a given day, and you know the arrival and departure time of each customer. If a customer departs at the same moment as another arrives, they are both considered to be in the restaurant at that moment. Your task is to find out the highest number of customers that are in the restaurant at the same time. 

Consider the following example case:

Ravintolassa käy päivän aikana $$n$$ asiakasta ja tiedät, milloin kukin asiakas saapuu ja lähtee. Jos asiakas lähtee samalla hetkellä kuin toinen asiakas saapuu, tulkintana on, että he ovat yhtä aikaa ravintolassa. Tehtäväsi on selvittää suurin määrä asiakkaita, jotka ovat yhtä aikaa ravintolassa.

Tarkastellaan esimerkkinä seuraavaa tilannetta:

Customer | Arrival time | Departure time
--- | ---
#1 | 6 | 8
#2 | 3 | 7
#3 | 6 | 9
#4 | 1 | 5
#5 | 2 | 8

Here the highest number of customers is 4: The customers #1, #2, #3 and #5 are all in the restaurant during the time period 6–7.

Tässä tapauksessa suurin määrä asiakkaita on 4 asiakasta: asiakkaat #1, #2, #3 ja #5 ovat yhtä aikaa ravintolassa aikavälillä 6–7.

</div>

A useful approach in this kind of a task is to process events in order of time. There are two types of events: customer arrivals and customer departures. With each event the number of customers increases or decreases by one.

In our example case, the events are:

Tällaisessa tehtävässä hyvä lähestymistapa on tarkastella tapahtumia aikajärjestyksessä. Tapahtumia on kahdenlaisia: asiakas saapuu ravintolaan tai asiakas lähtee ravintolasta. Jokaisen tapahtuman yhteydessä asiakkaiden määrä kasvaa tai vähenee yhdellä.

Esimerkin tapauksessa tapahtumat ovat:

Time | Event | Customer count
--- | ---
1 | Customer #4 arrives | 1
2 | Customer #5 arrives | 2
3 | Customer #2 arrives | 3
5 | Customer #4 departs | 2
6 | Customer #1 arrives | 3
6 | Customer #3 arrives | 4
7 | Customer #2 departs | 3
8 | Customer #1 departs | 2
8 | Customer #5 departs | 1
9 | Customer #3 departs | 0

We can solve the task by creating a list of the customer events and sorting it by time. Then we can go through the list while maintaining a counter of customers.

In the following function, the lists `arrivals` and `departures` contain the customer arrival and departure times. In our example case, `arrivals` is `[6, 3, 6, 1, 2]` and `departures` is `[8, 7, 9, 5, 8]`.

Voimme ratkaista tehtävän tehokkaasti muodostamalla ensin asiakkaita vastaavat tapahtumat ja järjestämällä ne aikajärjestykseen. Tämän jälkeen voimme käydä läpi tapahtumat ja pitää yllä asiakkaiden määrää laskurissa.

Seuraavassa funktiossa listat `arrivals` ja `departures` sisältävät asiakkaiden saapumisajat ja lähtöajat. Esimerkin tapauksessa `arrivals` on `[6, 3, 6, 1, 2]` ja `departures` on `[8, 7, 9, 5, 8]`.

```python
def max_customers(arrivals, departures):
    events = []
    for time in arrivals:
        events.append((time, 1))
    for time in departures:
        events.append((time, 2))
        
    events.sort()
    
    counter = 0
    result = 0
    for event in events:
        if event[1] == 1:
            counter += 1
        if event[1] == 2:
            counter -= 1
        result = max(result, counter)
        
    return result
```

The function creates the list `events` and adds the customer arrival and departure events to the list as pairs. An arrival is represented as a pair `(time, 1)` and a departure as a pair `(time, 2)`. Then the list of events is sorted using the time as the primary key.

Next the function goes through the list of events while keeping track of the customer count in the variable `counter`. The variable `result` stores the highest customer count encountered so far.

The resulting algorithm consists of three parts. Creating the event list takes $$O(n)$$ time, since there are two events for each customer. Sorting the events takes $$O(n \log n)$$ time, and finally, iterating through the events takes $$O(n)$$ time. Thus the total time complexity of the algorithm is $$O(n \log n)$$.

Funktio luo listan `events`, johon lisätään jokaista asiakasta kohden kaksi tapahtumaa pareina. Asiakkaan saapumisaika lisätään muodossa `(time, 1)` ja asiakkaan lähtöaika muodossa `(time, 2)`. Sitten funktio järjestää listan, minkä seurauksena tapahtumat järjestyvät niiden aikojen mukaan.

Tapahtumien järjestämisen jälkeen lista `events` käydään läpi ja muuttuja `counter` pitää yllä asiakkaiden määrää. Muuttujaan `result` tallennetaan muuttujan `counter` suurin arvo tapahtumien käsittelyn aikana.

Tuloksena oleva algoritmi muodostuu kolmesta osasta. Tapahtumien luominen vie aikaa $$O(n)$$, koska jokaisesta asiakkaasta muodostetaan kaksi tapahtumaa. Tapahtumien järjestäminen vie aikaa $$O(n \log n)$$, ja tapahtumien läpikäynti vie aikaa $$O(n)$$. Niinpä koko algoritmin aikavaativuus on $$O(n \log n)$$.

## Miten järjestäminen toimii?

Järjestämisalgoritmille annetaan lista alkioita ja sen tehtävänä on saada alkiot suuruusjärjestykseen. Yleensä lähtökohtana on, että algoritmi voi vertailla alkioita toisiinsa sekä vaihtaa alkioiden paikkoja listalla.

Yksinkertaiset järjestämisalgoritmit perustuvat vierekkäisten alkioiden vaihtamiseen keskenään ja niiden aikavaativuus on $$O(n^2)$$. Yksi tällainen algoritmi on [lisäysjärjestäminen](../lisaysjarjestaminen), joka käy listan läpi vasemmalta oikealle ja siirtää kunkin alkion oikeaan kohtaan listan alkuosassa.

Järjestämiseen on olemassa myös tehokkaita algoritmeja, joiden aikavaativuus on $$O(n \log n)$$. Yksi tällainen algoritmi on [lomitusjärjestäminen](../lomitusjarjestaminen), joka järjestää ensin listan vasemman ja oikean puoliskon reskursiivisesti erikseen ja yhdistää sitten järjestetyt puoliskot kokonaiseksi järjestetyksi listaksi.

Pythonin käyttämä järjestämisalgoritmi on _Timsort_, jossa on sekä lisäysjärjestämisen että lomitusjärjestämisen piirteitä. Algoritmin aikavaativuus on $$O(n \log n)$$, ja se on suunniteltu niin, että se on erityisen tehokas monissa käytännössä vastaan tulevissa tilanteissa.

Yleisessä tapauksessa ei ole mahdollista luoda järjestämisalgoritmia, jonka aikavaativuus olisi tehokkaampi kuin $$O(n \log n)$$. Tämä voidaan todistaa [määrittämällä alaraja](../jarjestamisen-alaraja) sille, montako kahden alkion vertailua algoritmissa tulee olla pahimmassa tapauksessa.

### Järjestämisen toiminnan tutkiminen

Seuraava koodi havainnollistaa, mitä Python tekee järjestäessään listan sisällön:

```python
import functools

def cmp(a, b):
    print("compare", a, b)
    return a - b

numbers = [4, 1, 3, 2]
numbers.sort(key=functools.cmp_to_key(cmp))
print(numbers)
```

Kun metodia `sort` kutsutaan yllä olevalla tavalla, se vertailee listalla olevien alkioiden järjestystä kutsumalla funktiota `cmp`. Funktio `cmp` saa parametreina alkiot `a` ja `b` ja sen tulee palauttaa

* negatiivinen arvo, jos `a` on pienempi kuin `b`, 
* positiivinen arvo, jos `a` on suurempi kuin `b`, ja
* nolla, jos `a` ja `b` ovat yhtä suuria.

Tässä `cmp` on toteutettu niin, että se palauttaa lausekkeen `a - b` arvon, minkä ansiosta se järjestää alkiot pienimmästä suurimpaan.

Metodi `sort` muuttaa listan alkioiden järjestystä funktion `cmp` perusteella. Funktio `cmp` tulostaa kaikki tekemänsä vertailut, mikä antaa tietoa metodin `sort` tekemistä vertailuista. Koodin tulostus on seuraava:

```
compare 1 4
compare 3 1
compare 3 4
compare 3 1
compare 2 3
compare 2 1
[1, 2, 3, 4]
```

Tämä tarkoittaa, että metodi `sort` vertailee ensin lukuja 1 ja 4, sitten lukuja 3 ja 1, jne. Kuuden vertailun jälkeen metodi on saanut listan järjestykseen.

## Järjestäminen muissa kielissä

Eri ohjelmointikielissä on valmiita menetelmiä järjestämiseen. Kielten välillä on eroja siinä, mihin algoritmeihin järjestäminen perustuu, mutta yleensä valmiit menetelmät ovat tehokkaita ja ne on toteutettu hyvin.

C++:ssa on saatavilla funktio `std::sort`, jolle annetaan parametrina iteraattori järjestettävän välin alkuun ja loppuun. Funktiota voidaan käyttää seuraavasti:

```cpp
std::vector<int> numbers;
...
std::sort(numbers.begin(), numbers.end());
```

Javassa voidaan käyttää luokan `Collections` metodia `sort`:

```java
ArrayList<Integer> numbers = new ArrayList<>();
...
Collections.sort(numbers);
```

JavaScriptissa taulukon metodi `sort` järjestää sen sisällön. Metodin käyttäminen voi kuitenkin aiheuttaa yllätyksiä:

```js
numbers = [2, 11, 1, 3];
numbers.sort();
console.log(numbers); // [1, 11, 2, 3]
```

Tässä järjestettävänä on kokonaislukuja sisältävä lista, mutta luku 11 menee järjestykseen ennen lukua 2. Syynä tähän on, että metodi `sort` käsittelee alkioita oletuksena merkkijonoina, jolloin `11` on pienempi kuin `2`. Metodille voi kuitenkin antaa seuraavasti vertailufunktion lukujen järjestämistä varten:

```js
numbers = [2, 11, 1, 3];
numbers.sort((a, b) => a - b);
console.log(numbers); // [1, 2, 3, 11]
```




---
title: 5. Järjestäminen
slug: osa5
hide: true
sections:
  - Järjestäminen Pythonissa
  - "Esimerkki: Pienin ero"
  - Hajautus vs. järjestäminen
  - Lisää järjestämisestä
  - "Esimerkki: Ravintola"
  - Miten järjestäminen toimii?
  - Järjestämisen alaraja
  - Järjestäminen muissa kielissä
---

# 5. Järjestäminen

_Järjestäminen_ (_sorting_) on klassinen algoritmiikan ongelma, jossa lista alkioita tulee järjestää suuruusjärjestykseen. Moderneissa ohjelmointikielissä on valmiita tapoja järjestämiseen, kuten Pythonin metodi `sort` ja funktio `sorted`.

Järjestämiseen on olemassa tehokkaita algoritmeja, joiden aikavaativuus on $$O(n \log n)$$. Tämän ansiosta järjestämistä voidaan käyttää osana tehokasta algoritmia. Usein ideana on järjestää ensin algoritmille annetut tiedot ja käsitellä niitä sitten järjestystä hyödyntäen.

## Järjestäminen Pythonissa

Pythonissa listassa on metodi `sort`, joka järjestää sen sisällön:

```python
numbers = [4, 2, 1, 2, 5, 4, 5, 2]
numbers.sort()
print(numbers) # [1, 2, 2, 2, 4, 4, 5, 5]
```

Pythonissa on myös funktio `sorted`, joka palauttaa listan järjestettynä:

```python
numbers = [4, 2, 1, 2, 5, 4, 5, 2]
print(sorted(numbers)) # [1, 2, 2, 2, 4, 4, 5, 5]
```

Näissä tavoissa erona on, että metodi `sort` muuttaa olemassa olevaa listaa, kun taas funktio `sorted` palauttaa uuden listan.

Metodi `sort` ja funktio `sorted` on toteutettu tehokkaasti, ja niiden aikavaativuus on $$O(n \log n)$$.

## Esimerkki: Pienin ero

{: .note-title }
Tehtävä
<div class="note" markdown="1">

Annettuna on lista lukuja. Mikä on pienin ero kahden luvun välillä?

Esimerkiksi kun lista on $$[25,1,11,19,33,13,4,40]$$, haluttu vastaus on $$2$$, koska pienin ero on lukujen $$11$$ ja $$13$$ välillä.

</div>

Voimme ratkaista tämän tehtävän tehokkaasti järjestämisen avulla, koska järjestämisen jälkeen listassa ovat vierekkäin luvut, joiden välillä on pienin ero. Tämän ansiosta pienin ero voidaan löytää helposti käymällä läpi lista vasemmalta oikealle ja vertaamalla joka kohdassa vierekkäisiä lukuja.

Yllä olevassa esimerkissä lista järjestettynä on $$[1,4,11,13,19,25,33,40]$$ ja luvut $$11$$ ja $$13$$ ovat vierekkäin.

Seuraava funktio `min_diff` toteuttaa algoritmin:

```python
def min_diff(numbers):
    numbers = sorted(numbers)
    n = len(numbers)
    result = numbers[1] - numbers[0]
    for i in range(2, n):
        result = min(result, numbers[i] - numbers[i - 1])
    return result
```

Algoritmi järjestää ensin listan ajassa $$O(n \log n)$$ ja käy sitten läpi kaikki vierekkäiset luvut silmukalla ajassa $$O(n)$$, joten algoritmin aikavaativuus on $$O(n \log n)$$.

Huomaa, että voisimme käyttää funktion alussa myös listan metodia `sort`:

```python
def min_diff(numbers):
    numbers.sort()
    ...
```

Tässä on kuitenkin ongelmana, että parametrina annetun listan järjestäminen heijastuu myös funktion `min_diff` kutsukohtaan. Tämä ei ole toivottava ilmiö, koska funktion ei pitäisi muuttaa listan sisältöä. Seuraavat koodit havainnollistavat asiaa:


{: .code-title }
Käytössä `sort`
```python
numbers = [25, 1, 11, 19, 33, 13, 4, 40]
print(min_diff(numbers)) # 2
print(numbers) # [1, 4, 11, 13, 19, 25, 33, 40]
```

{: .code-title }
Käytössä `sorted`
```python
numbers = [25, 1, 11, 19, 33, 13, 4, 40]
print(min_diff(numbers)) # 2
print(numbers) # [25, 1, 11, 19, 33, 13, 4, 40]
```

Kun käytössä on metodi `sort`, funktion `min_diff` kutsuminen järjestää sivuvaikutuksena listan `numbers`. Kun käytössä on funktio `sorted`, lista `numbers` ei muutu, koska funktio `sorted` luo uuden järjestetyn listan.

Yleensä hyvä valinta on käyttää funktiota `sorted`, jolloin järjestäminen ei aiheuta sivuvaikutuksia.

## Hajautus vs. järjestäminen

Monessa tehtävässä on kaksi mahdollisuutta tehokkaan ratkaisun luomiseen: hajautus tai järjestäminen. Tarkastellaan esimerkkinä tehtävää, jonka ratkaisimme aiemmin hajautuksen avulla:

{: .note-title }
Tehtävä
<div class="note" markdown="1">

Annettuna on lista lukuja. Montako eri lukua listalla on?

Esimerkiksi kun lista on $$[3,1,2,1,5,2,2,3]$$, haluttu vastaus on $$4$$, koska eri luvut ovat $$1$$, $$2$$, $$3$$ ja $$5$$.

</div>

Ratkaisimme tehtävän aiemmin hajautuksen avulla näin:

{: .code-title }
Algoritmi 1
```python
def count_distinct(numbers):
    seen = set()
    for x in numbers:
        seen.add(x)
    return len(seen)
```

Voimme ratkaista tehtävän myös toisella tavalla järjestämisen avulla. Koska järjestetyssä listassa yhtä suuret luvut ovat peräkkäin, voimme käydä järjestetyn listan läpi ja kasvattaa laskuria aina luvun vaihtuessa.

Tässä on järjestämistä käyttävä algoritmi:

{: .code-title }
Algoritmi 2
```python
def count_distinct(numbers):
    numbers = sorted(numbers)    
    result = 1
    for i in range(1, n):
        if numbers[i] != numbers[i - 1]:
            result += 1
    return result
```

Hajautusta käyttävä algoritmi vie aikaa $$O(n)$$ ja järjestämistä käyttävä algoritmi vie aikaa $$O(n \log n)$$, mutta miten nopeita algoritmit ovat käytännössä?

Tehdään seuraavaksi testi, joka vertailee algoritmien tehokkuutta. Koska molemmat algoritmit ovat tehokkaita, toteutetaan testi niin, että listan koko on aina suuri ($$n=10^7$$). Koska listalla olevien lukujen suuruus saattaa vaikuttaa tehokkuuteen, luodaan lista niin, että jokainen luku on satunnainen luku väliltä $$1 \dots k$$. Tämän avulla voimme tutkia, miten $$k$$:n muuttuminen vaikuttaa tehokkuuteen.

Testikoneella tulokset ovat seuraavat:

| Luvun yläraja $$k$$ | Algoritmi 1 (hajautus) | Algoritmi 2 (järjestäminen)
| --- | --- | --- | 
| $$10^3$$ | 0.46 s | 3.18 s |
| $$10^4$$ | 0.56 s | 4.50 s |
| $$10^5$$ | 1.16 s | 5.74 s |
| $$10^6$$ | 2.56 s | 6.38 s |
| $$10^7$$ | 2.56 s | 6.48 s |

Tässä tapauksessa vaikuttaa, että hajautusta käyttävä algoritmi on tehokkaampi. Se on myös koodiltaan yksinkertaisempi, koska silmukassa riittää lisätä listan luvut `set`-rakenteeseen eikä vertailla vierekkäisiä lukuja keskenään.

## Lisää järjestämisestä

### Käänteinen järjestäminen

Parametri `reverse` muuttaa järjestämisen suunnan käänteiseksi:

```python
numbers = [2, 4, 3, 5, 6, 1, 8, 7]
numbers.sort(reverse=True)
print(numbers) # [8, 7, 6, 5, 4, 3, 2, 1]
```

### Moniosaiset alkiot

Jos järjestettävät alkiot ovat tupleja tai listoja, järjestys on ensisijaisesti ensimmäisen alkion mukaan, toissijaisesti toisen alkion mukaan, jne.

Esimerkiksi listassa olevat parit järjestyvät näin:

```python
pairs = [(3, 5), (1, 3), (1, 2), (2, 4)]
pairs.sort()
print(pairs) # [(1, 2), (1, 3), (2, 4), (3, 5)]
```

### Alkioiden vertailutapa

Parametrilla `key` voidaan määritellä funktio, joka muuttaa alkioita ennen kuin niitä vertaillaan toisiinsa. Parametria voidaan käyttää esimerkiksi näin:

```python
numbers = [4, -1, 6, 2, -7, 8, 3, -5]
numbers.sort(key=abs)
print(numbers) # [-1, 2, 3, 4, -5, 6, -7, 8]
```

Tässä funktiona on `abs` eli itseisarvo, minkä seurauksena luvut järjestetään suuruuden mukaan välittämättä niiden etumerkistä.

### Oma luokka

Pythonissa luokan olioita voidaan järjestää, kun luokkaan on toteutettu riittävästi metodeita olioiden vertailua varten. Esimerkiksi riittää, että on toteutettu metodit `__eq__` ja `__lt__`, jolloin olioita voidaan vertailla operaattoreiden `==` ja `<` avulla. Seuraava koodi havainnollistaa asiaa:

```python
class Location:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return (self.x, self.y) == (other.x, other.y)

    def __lt__(self, other):
        return (self.x, self.y) < (other.x, other.y)

    def __repr__(self):
        return str((self.x, self.y))

locations = []
locations.append(Location(1, 4))
locations.append(Location(4, 5))
locations.append(Location(2, 2))
locations.append(Location(1, 2))

locations.sort()

print(locations) # [(1, 2), (1, 4), (2, 2), (4, 5)]
```

## Esimerkki: Ravintola

{: .note-title }
Tehtävä
<div class="note" markdown="1">

Ravintolassa käy päivän aikana $$n$$ asiakasta ja tiedät, milloin kukin asiakas saapuu ja lähtee. Jos asiakas lähtee samalla hetkellä kuin toinen asiakas saapuu, tulkintana on, että he ovat yhtä aikaa ravintolassa. Tehtäväsi on selvittää suurin määrä asiakkaita, jotka ovat yhtä aikaa ravintolassa.

Tarkastellaan esimerkkinä seuraavaa tilannetta:

Asiakas | Saapumisaika | Lähtöaika
--- | ---
#1 | 6 | 8
#2 | 3 | 7
#3 | 6 | 9
#4 | 1 | 5
#5 | 2 | 8

Tässä tapauksessa suurin määrä asiakkaita on 4 asiakasta: asiakkaat #1, #2, #3 ja #5 ovat yhtä aikaa ravintolassa aikavälillä 6–7.

</div>

Tällaisessa tehtävässä hyvä lähestymistapa on tarkastella tapahtumia aikajärjestyksessä. Tapahtumia on kahdenlaisia: asiakas saapuu ravintolaan tai asiakas lähtee ravintolasta. Jokaisen tapahtuman yhteydessä asiakkaiden määrä kasvaa tai vähenee yhdellä.

Esimerkin tapauksessa tapahtumat ovat:

Aika | Tapahtuma | Asiakasmäärä
--- | ---
1 | Asiakas #4 saapuu ravintolaan | 1
2 | Asiakas #5 saapuu ravintolaan | 2
3 | Asiakas #2 saapuu ravintolaan | 3
5 | Asiakas #4 lähtee ravintolasta | 2
6 | Asiakas #1 saapuu ravintolaan | 3
6 | Asiakas #3 saapuu ravintolaan | 4
7 | Asiakas #2 lähtee ravintolasta | 3
8 | Asiakas #1 lähtee ravintolasta | 2
8 | Asiakas #5 lähtee ravintolasta | 1
9 | Asiakas #3 lähtee ravintolasta | 0

Tämän ansiosta voimme ratkaista tehtävän tehokkaasti muodostamalla ensin asiakkaita vastaavat tapahtumat ja järjestämällä ne aikajärjestykseen. Tämän jälkeen voimme käydä läpi tapahtumat ja pitää yllä asiakkaiden määrää laskurissa.

Seuraavassa funktiossa listat `arrivals` ja `departures` sisältävät asiakkaiden saapumisajat ja lähtöajat. Esimerkin tapauksessa `arrivals` on `[6, 3, 6, 1, 2]` ja `departures` on `[8, 7, 9, 5, 8]`.


```python
def max_customers(arrivals, departures):
    events = []
    for time in arrivals:
        events.append((time, 1))
    for time in departures:
        events.append((time, 2))
        
    events = sorted(events)
    
    counter = 0
    result = 0
    for event in events:
        if event[1] == 1:
            counter += 1
        if event[1] == 2:
            counter -= 1
        result = max(result, counter)
        
    return result
```

Funktio luo listan `events`, johon lisätään jokaista asiakasta kohden kaksi tapahtumaa pareina. Asiakkaan saapumisaika lisätään muodossa `(time, 1)` ja asiakkaan lähtöaika muodossa `(time, 2)`. Sitten funktio järjestää listan, minkä seurauksena tapahtumat järjestyvät niiden ajan mukaan.

Tapahtumien järjestämisen jälkeen lista `events` käydään läpi ja muuttuja `counter` pitää yllä asiakkaiden määrää. Muuttujaan `result` tallennetaan muuttujan `counter` suurin arvo tapahtumien käsittelyn aikana.

Tuloksena oleva algoritmi muodostuu kolmesta osasta. Tapahtumien luominen vie aikaa $$O(n)$$, koska jokaisesta asiakkaasta muodostetaan kaksi tapahtumaa. Tapahtumien järjestäminen vie aikaa $$O(n \log n)$$ ja tapahtumien läpikäynti vie aikaa $$O(n)$$. Niinpä koko algoritmin aikavaativuus on $$O(n \log n)$$.

## Miten järjestäminen toimii?

Järjestämisalgoritmille annetaan lista alkioita ja sen tehtävänä on saada alkiot suuruusjärjestykseen. Yleensä lähtökohtana on, että algoritmi voi vertailla alkioita toisiinsa sekä vaihtaa alkioiden paikkoja listalla.

Yksinkertaiset järjestämisalgoritmit perustuvat vierekkäisten alkioiden vaihtamiseen keskenään ja niiden aikavaativuus on $$O(n^2)$$. Yksi tällainen algoritmi on _lisäysjärjestäminen_ (_insertion sort_), joka käy listan läpi vasemmalta oikealle ja siirtää kunkin alkion oikeaan kohtaan listan alkuosassa.

Vain vierekkäisiä alkioita käsittelevä järjestämisalgoritmi ei voi koskaan olla tehokas, koska tarvittava vaihtojen määrä voi olla suuri. Esimerkiksi jos lista on käänteisessä järjestyksessä, tarvitaan luokkaa $$n^2$$ vaihtoa. Yleisemmin tarvittava vierekkäisten alkioiden vaihtojen määrä on yhtä suuri kuin listan _inversioiden_ määrä. Inversio tarkoittaa listalla olevaa alkioparia, jotka ovat väärässä järjestyksessä.

Järjestämiseen on olemassa myös tehokkaita algoritmeja, joiden aikavaativuus on $$O(n \log n)$$. Yksi tällainen algoritmi on _lomitusjärjestäminen_ (_merge sort_), joka järjestää ensin listan vasemman ja oikean puoliskon erikseen ja yhdistää sitten järjestetyt puoliskot kokonaiseksi järjestetyksi listaksi. Algoritmi toimii rekursiivisesti niin, että se järjestää myös puoliskot vastaavalla tavalla, jne.

Pythonin käyttämä järjestämisalgoritmi on _Timsort_, jossa on sekä lisäysjärjestämisen että lomitusjärjestämisen piirteitä. Algoritmin aikavaativuus on $$O(n \log n)$$, ja se on suunniteltu niin, että se on erityisen tehokas monissa käytännössä vastaan tulevissa tilanteissa.

### Järjestämisen toiminnan tutkiminen

Seuraava koodi havainnollistaa, mitä Python tekee järjestäessään listan sisällön:

```python
import functools

def cmp(a, b):
    print("compare", a, b)
    return a - b

numbers = [4, 1, 3, 2]
numbers.sort(key=functools.cmp_to_key(cmp))
print(numbers)
```

Kun metodia `sort` kutsutaan yllä olevalla tavalla, se vertailee listalla olevien alkioiden järjestystä kutsumalla funktiota `cmp`. Funktio `cmp` saa parametreina alkiot `a` ja `b` ja sen tulee palauttaa

* negatiivinen arvo, jos `a` on pienempi kuin `b`, 
* positiivinen arvo, jos `a` on suurempi kuin `b`, ja
* nolla, jos `a` ja `b` ovat yhtä suuria.

Metodi `sort` muuttaa listan alkioiden järjestystä funktion `cmp` perusteella. Funktio `cmp` tulostaa kaikki tekemänsä vertailut, mikä antaa tietoa metodin `sort` tekemistä vertailuista. Koodin tulostus on seuraava:

```
compare 1 4
compare 3 1
compare 3 4
compare 3 1
compare 2 3
compare 2 1
[1, 2, 3, 4]
```

Tämä tarkoittaa, että metodi `sort` vertailee ensin lukuja 1 ja 4, sitten lukuja 3 ja 1, jne. Kuuden vertailun jälkeen metodi on saanut listan järjestykseen.

## Järjestämisen alaraja

On mahdollista osoittaa, että $$O(n \log n)$$ on paras mahdollinen aikavaativuus yleiskäyttöiselle järjestämisalgoritmille. Tässä oletuksena on, että algoritmi vertailee alkioita toisiinsa ja muuttaa sen perusteella niiden järjestystä.

Tarkastellaan tilannetta, jossa algoritmille annetaan $$n$$ alkion lista, jossa jokainen luku väliltä $$1 \dots n$$ esiintyy tasan kerran. Listan alkiot voivat olla $$n!$$ eri järjestyksessä, ja kussakin tapauksessa algoritmin tulee toimia eri tavalla, jotta lista tulee järjestykseen.

Kun algoritmi vertailee kahta alkiota toisiinsa, tämä antaa algoritmille tietoa, jota se voi käyttää järjestämisessä. Tarkastellaan tilannetta, jossa $$n=3$$ ja algoritmi ei ole vielä tehnyt vertailuja. Koska algoritmilla ei ole vielä tietoa listasta, algoritmin näkökulmasta lista voi olla mikä tahansa seuraavista:

$$[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]$$

Oletetaan sitten, että algoritmi vertailee listan kahta ensimmäistä alkiota toisiinsa ja saa tietää, että ensimmäinen alkio on suurempi kuin toinen alkio. Tämän perusteella algoritmi pystyy rajaamaan tilannetta niin, että lista on jokin seuraavista:

$$[2,1,3], [3,1,2], [3,2,1]$$

Jotta algoritmi toimii oikein, sen täytyy päästä vertailuja tekemällä tilanteeseen, jossa on vain yksi mahdollinen lista ja algoritmi voi järjestää sen oikealla tavalla. Listojen määrä alussa on $$n!$$ ja jokaisen vertailun jälkeen ainakin puolet listoista voi jäädä jäljelle. Niinpä tarvitaan ainakin $$\log_2(n!)$$ vertailua, ennen kuin algoritmi on saanut varmasti riittävästi tietoa listasta. Tästä saadaan alaraja

$$\log_2(n!) = \log_2(1)+\log_2(2)+\dots+\log_2(n) \ge (n/2) \log_2(n/2)$$

eli algoritmin täytyy tehdä luokkaa $$n \log n$$ vertailua.

Huomaa, että järjestäminen voi olla mahdollista toteuttaa tehokkaammin, jos sen riittää toimia vain tietyn tyyppisillä alkioilla. Jos esimerkiksi alkiot ovat pieniä kokonaislukuja, järjestäminen on mahdollista toteuttaa ajassa $$O(n)$$. Yksi tällainen algoritmi on _laskemisjärjestäminen_ (_counting sort_).

## Järjestäminen muissa kielissä

Eri ohjelmointikielissä on valmiita menetelmiä järjestämiseen. Kielten välillä on eroja siinä, mihin algoritmeihin järjestäminen perustuu, mutta yleensä valmiit menetelmät ovat tehokkaita ja ne on toteutettu hyvin.

C++:ssa on saatavilla funktio `std::sort`, jolle annetaan parametrina iteraattori järjestettävän välin alkuun ja loppuun. Funktiota voidaan käyttää seuraavasti:

```cpp
std::vector<int> numbers;
...
std::sort(numbers.begin(), numbers.end());
```

Javassa voidaan käyttää luokan `Collections` metodia `sort`:

```java
ArrayList<Integer> numbers = new ArrayList<>();
...
Collections.sort(numbers);
```

JavaScriptissa taulukon metodi `sort` järjestää sen sisällön. Metodin käyttäminen voi kuitenkin aiheuttaa yllätyksiä:

```js
numbers = [1, 2, 3, 11, 12, 13];
numbers.sort();
console.log(numbers); // [1, 11, 12, 13, 2, 3]
```

Syynä tähän on, että metodi `sort` käsittelee alkioita oletuksena merkkijonoina, minkä vuoksi esimerkiksi `11` on pienempi kuin `2`. Metodille voi kuitenkin antaa seuraavasti vertailufunktion lukujen järjestämistä varten:

```js
numbers = [1, 2, 3, 11, 12, 13];
numbers.sort((a, b) => a - b);
console.log(numbers); // [1, 2, 3, 11, 12, 13]
```
