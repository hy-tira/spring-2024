---
title: 12. Binary search tree
slug: osa12
hide: true
sections:
  - Joukko binääripuuna
  - Toteutus Pythonilla
  - Tasapainoisuus
  - "Esimerkki: Hotelli"
  - Miksi ei Pythonissa?
  - Muiden kielten toteutukset
---

# 12. Binary search tree

Binary search tree is a data structure that maintains a set of elements. The basic operations are the same as with hashing: elements can be added, searched and removed efficiently.

Binary search tree differs from hashing in that it maintains the elements in order. Because of this, the smallest and the largest element in the set can be found efficiently, which is not possible with hashing.

The Python standard library does not have an implementation of a binary search tree, which them a little bit more difficult to use in Python. In this chapter, we develop our _own_ implementation of the binary search tree.

_Binäärihakupuu_ (_binary search tree_) on tietorakenne, joka pitää yllä joukkoa alkioista. Sen perustoiminnot ovat samat kuin hajautuksessa: alkioita pystyy lisäämään, etsimään ja poistamaan tehokkaasti.

Binäärihakupuun keskeinen ero hajautukseen verrattuna on, että se säilyttää alkioita suuruusjärjestyksessä. Tämän ansiosta voidaan etsiä esimerkiksi tehokkaasti joukon pienin tai suurin alkio, mikä ei olisi mahdollista hajautuksen avulla.

Pythonin standardikirjastossa ei ole binäärihakupuun toteutusta, minkä vuoksi sen käyttäminen Pythonissa on hankalampaa kuin hajautuksen käyttäminen. Tässä luvussa toteutamme _itse_ binäärihakupuun Pythonilla.

## Set as a binary tree

A binary search tree is a binary tree, where each node stores one element of the set. For example, the following binary search tree corresponds to the set $$\{2,3,5,7,8,9\}$$:

Binäärihakupuu on binääripuu, jonka jokaisessa solmussa on yksi joukon alkioista. Esimerkiksi seuraava binäärihakupuu vastaa joukkoa $$\{2,3,5,7,8,9\}$$:

![](../bhp.png)

A binary search tree is organized so that for every node the elements in the left subtree are smaller that the element in the node, and symmetrically the elements in the right subtree are larger than the element in the node. For example in the tree above, the elements in the left subtree of the root are $$2$$ and $$3$$, which are smaller than the root element $$5$$. Similarly, the elements  in the right subtree are $$7$$, $$8$$ and $$9$$, all of which are larger than the root element $$5$$.

The elements can be located freely in the binary tree as long as the above ordering condition is satisfied by every node. Thus the same set can be represented by different binary search trees. For example, the following two binary search trees both represent the set $$\{1,2,3,4,5\}$$:

Binäärihakupuun alkiot on järjestetty niin, että jokaisessa solmussa kaikki vasemman alipuun alkiot ovat pienempiä kuin solmun alkio ja vastaavasti kaikki oikean alipuun alkiot ovat suurempia kuin alkio. Esimerkiksi yllä olevassa kuvassa juuren vasemman alipuun alkiot $$2$$ ja $$3$$ ovat pienempiä kuin juuren alkio $$5$$. Vastaavasti juuren oikean alipuun alkiot $$7$$, $$8$$ ja $$9$$ ovat suurempia kuin juuren alkio $$5$$.

Huomaa, että solmujen sijoittuminen binäärihakupuuhun voidaan valita muuten vapaasti, kunhan äsken mainittu järjestykseen liittyvä ehto pätee. Niinpä on erilaisia tapoja esittää tietty joukko binäärihakupuuna. Esimerkiksi seuraavat kaksi binäärihakupuuta vastaavat molemmat joukkoa $$\{1,2,3,4,5\}$$:

![](../bhp_1.png)

Let us next consider how set operations can be implemented using a binary search tree.

Katsotaan seuraavaksi, miten binäärihakupuun avulla voidaan toteuttaa joukkoon liittyviä operaatioita.

### Finding an element

When searching for an element, we start at the root. If the element in the node is smaller than the query element, the search continues in the right subtree. If the element in the node is larger than the query element, the search continues in the left subtree. This continues until we find the element, or until there is no child in the direction where the search should continue. The latter case means that the query element is not in the set.

For example, the search route for an element $$7$$ is illustrated by the following image:

Kun halutaan etsiä joukosta alkiota, lähdetään liikkeelle puun juuresta. Jos solmussa oleva alkio on pienempi kuin etsittävä alkio, siirrytään oikeaan lapseen. Jos solmussa oleva alkio on suurempi kuin etsittävä alkio, siirrytään vasempaan lapseen. Näin jatketaan, kunnes haluttu alkio on löytynyt tai solmulla ei ole lasta, johon tulisi siirtyä. Jälkimmäinen tapaus tarkoittaa, ettei etsittävää alkiota ole joukossa.

Esimerkiksi alkio $$7$$ voidaan löytää puusta kulkemalla seuraavaa reittiä:

![](../bhp_2.png)

The search starts at the root, where the element is $$5$$. This is smaller than the element $$7$$ and the search continues in the right child. The element there is $$8$$, which is lager than the element $$7$$. Thus the search continues to the left child, where the element $$7$$ is found. 

Alkion etsiminen alkaa juuresta, jossa on alkio $$5$$. Koska tämä on pienempi kuin etsittävä alkio $$7$$, siirrytään oikeaan lapseen. Tässä solmussa on alkio $$8$$, joka on suurempi kuin etsittävä alkio $$7$$. Niinpä haku jatkuu vasempaan lapseen, josta löytyy etsittävä alkio $$7$$.

### Adding an element

When adding an element, the first stage is to search for the element in the set. If the element is found, no addition is performed, because a set can contain an element only once. If the element is not found, a new node is inserted where the seach would have continued next, and the new element is stored in the new node.

For example, the following image illustrates the addition of an element $$4$$:

Joukkoon voidaan lisätä alkio etsimällä ensin alkiota joukosta. Jos alkio löytyy, sitä ei lisätä, koska sama alkio voi esiintyä joukossa vain kerran. Jos alkiota ei löydy, puuhun lisätään uusi solmu siihen kohtaan, johon haku olisi edennyt seuraavaksi, ja uusi alkio sijoitetaan siihen.

Esimerkiksi alkio $$4$$ voidaan lisätä joukkoon seuraavasti:

![](../bhp_3.png)

The search for the element $$4$$ start at the root, where the element is $$5$$. Next the search goes to the left child, where the element is $$3$$. Here the search should continue to the right child but the node has no right child. This means that the element $$4$$ is not in the tree, and a new node storing the element $$4$$ is added as that missing right child. This ensures that a later search for the element $$4$$ will reach the node.

Alkion $$4$$ etsiminen alkaa juuresta, jossa on alkio $$5$$. Tästä siirrytään vasempaan lapseen, jossa on alkio $$3$$. Tästä tulisi siirtyä oikeaan lapseen, mutta solmulla ei ole oikeaa lasta. Tämä tarkoittaa, ettei alkiota $$4$$ ole vielä puussa ja se tulee lisätä solmun oikeaksi lapseksi. Tämän ansiosta alkio löytyy, kun sitä etsitään myöhemmin.

### Smallest element

A search for the smallest element of the set starts at the root and always continue to the child as long as possible. When going left is no more possible, the smallest element has been found.

Joukon pienin alkio löytyy lähtemällä liikkeelle juuresta ja etenemällä solmun vasempaan lapseen niin kauan, kuin tämä on mahdollista. Kun tämä ei ole enää mahdollista, pienin alkio on löytynyt.

### Largest element

A search for the largest element follows a similar procedure but always goes to the right instead of the left.

Tässä voidaan menetellä vastaavasti kuin pienimmän alkion etsimisessä, mutta joka vaiheessa siirrytään solmun oikeaan lapseen.

### Successor

The successor of an element $$x$$ in the set is the smallest element that is larger than $$x$$. A search for the successor starts at the root, goes left when the element in the node is larger than $x$, and otherwise right. The search continues until there is nowhere to go. The desired element is among those encountered during the search, i.e., the smallest of them that is larger than $x$.

Tavoitteena on löytää pienin alkio, joka on suurempi kuin $$x$$. Lähdetään liikkeelle juuresta ja siirrytään vasempaan lapseen aina, kun solmun alkio on suurempi kuin $$x$$, ja muuten oikeaan lapseen. Haku päättyy, kun siirtyminen ei ole mahdollista. Haluttu alkio on pienin alkiota $$x$$ suurempi alkio kaikista alkioista, joiden kautta reitti kulki.

### Predecessor

The predecessor of an element $$x$$ in the set is the largest element that is smaller than $$x$$. A predecessor search is symmetric to successor search: go right when the element is smaller than $x$. The predecessor is the largest element smaller than $x$ among the encountered elements.

Tavoitteena on löytää suurin alkio, joka on pienempi kuin $$x$$. Tässä voidaan toimia käänteisesti edelliseen kohtaan verrattuna: siirrytään oikeaan lapseen aina, kun solmun alkio on pienempi kuin $$x$$. Haluttu alkio on suurin alkiota $$x$$ pienempi alkio reitillä olleista alkioista.

### Removing an element

When removing and element, the first step is to find the node containing the element. The next step depends on the situation of the node in the tree. There are three cases:

* The node has no children. Then the node can just be removed.
* The node has one child. Then the node can be removed and replaced by the its only child.
* The node has two children. Then find the successor of the element, and swap the elements in the two nodes. Then the new node of the element can be removed, because it has at most one child.

The following image shows an example, where we want remove the element $$5$$. Since the node with element $$5$$ has two children, the element $$5$$ is swapped with its successor $$7$$. Then the new node of the element $$5$$ is easy to remove, because it has no children.

Kun joukosta halutaan poistaa alkio, etsitään ensin alkiota vastaava solmu puusta. Tässä on kolme mahdollista tapausta:

* Solmulla ei ole lapsia. Tällöin solmu voidaan poistaa suoraan puusta.
* Solmulla on yksi lapsi. Tällöin voidaan poistaa solmu puusta ja siirtää sen tilalle solmun ainoa lapsi.
* Solmulla on kaksi lasta. Tällöin etsitään pienin alkiota suurempi alkio ja vaihdetaan keskenään näiden solmujen alkiot. Tämän jälkeen alkio on helppoa poistaa, koska sen solmulla on enintään yksi lapsi.

Seuraava kuva näyttää esimerkin, jossa halutaan poistaa alkio $$5$$. Koska alkion $$5$$ solmulla on kaksi lasta, vaihdetaan ensin keskenään alkiot $$5$$ ja $$7$$. Tämän jälkeen alkio $$5$$ on helppoa poistaa, koska sillä ei ole lasta.

![](../bhp_4.png)

Notice that when the node has two children, the successor node cannot have a left child and can always be removed easily. Also, the swap of the two elements does not violate the ordering conditions relative to any other elements.

Huomaa, että kahden lapsen tapauksessa pienimmän alkiota suuremman alkion etsiminen takaa, että uudella solmulla ei voi olla kahta lasta. Niinpä uuden solmun pystyy aina poistamaan helposti.

## Implementation in Python

Next we will begin developing an implementation of a binary search tree in Python. The goal here is a class `TreeSet` that can be used as follows:

Aletaan seuraavaksi toteuttaa binäärihakupuuta Pythonilla. Tavoitteena on saada aikaan luokka `TreeSet`, jota voidaan käyttää seuraavasti:

```python
s = TreeSet()

s.add(1)
s.add(2)
s.add(3)

print(2 in s) # True
print(4 in s) # False

print(s) # [1, 2, 3]
```

The method `add` adds an element to the set, the operator `in` reports if an element is in the set, and the string representation of the set is a list of its elements.

The following class `Node` stores the information related to a node in the tree:

Tässä metodi `add` lisää alkion joukkoon, operaattori `in` ilmoittaa, onko alkio joukossa, ja joukon merkkijonoesityksenä on lista sen alkioista.

Seuraava luokka `Node` sisältää tiedon puussa olevasta solmusta:

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
```

Each node contains three attributes: the element in the ode (`value`) and references to the children (`left` and `right`).

The class `TreeSet` implements the binary search tree. Here is an initial template:

Jokaiseen solmuun liittyy kolme tietoa: solmussa olevan alkion arvo (`value`) sekä viittaus solmun vasempaan ja oikeaan lapseen (`left` ja `right`).

Luokka `TreeSet` sisältää varsinaisen binäärihakupuun toteutuksen. Tässä on pohja luokalle:

```python
class TreeSet:
    def __init__(self):
        self.root = None
```

The method `__init__` defines a reference to the root of the tree. Initially, there are no nodes, which is why `root` is `None`.

Metodi `__init__` luo muuttujan `root`, jossa on viittaus puun juureen. Alussa puussa ei ole yhtään solmua, minkä vuoksi `root` on `None`.

### Adding an element

The following method `add` adds an element to the set:

Seuraava metodi `add` lisää alkion joukkoon:

```python
    def add(self, value):
        if not self.root:
            self.root = Node(value)
            return

        node = self.root
        while True:
            if node.value == value:
                return
            if node.value > value:
                if not node.left:
                    node.left = Node(value)
                    return
                node = node.left
            else:
                if not node.right:
                    node.right = Node(value)
                    return
                node = node.right
```

If the tree is empty, the element is added to a new node that becomes the root of the tree. Otherwise, the method performs a search starting from the root.

If a node containing the element is found, the method ends, because the element is already in the set. If the element in the node is larger than element to be added, the search goes left, and if the element in the node is smaller than element to be added, the search goes right. If the there is no child where the search should continue, the element is added to a new node that becomes the missing child, and the method ends.

Jos puu on tyhjä, alkio lisätään sen juureksi uuteen solmuun ja metodi päättyy. Muuten metodi etsii paikan alkiolle juuresta alkaen.

Jos solmun alkio on sama kuin lisättävä alkio, metodi päättyy, koska alkio on jo lisätty. Jos solmun alkio on suurempi kuin lisättävä alkio, haku jatkuu vasemmalle, ja jos solmun alkio on pienempi kuin lisättävä alkio, haku jatkuu oikealle. Jos solmulla ei ole lasta, johon haun tulisi jatkua, uusi alkio lisätään kyseiseksi lapseksi ja metodi päättyy.

### Finding an element

The following method `__contains__` checks if a given element is in the set. The method `__contains__` is called by the operator `in`. 

Seuraava metodi `__contains__` tarkastaa, onko joukossa tiettyä alkiota. Metodia `__contains__` kutsutaan, kun koodissa on operaattori `in`.

```python
    def __contains__(self, value):
        if not self.root:
            return False

        node = self.root
        while node:
            if node.value == value:
                return True
            if node.value > value:
                node = node.left
            else:
                node = node.right

        return False
```

If the tree is empty, the element is not in the tree and the method returns `False`. Otherwise the method searches for the element similarly as with addition. If the element is found, the method return `True`. If the element is not in the tree, the search will eventually go outside the tree (`node` becomes `None`), and the method ends and returns `False`.

Jos puu on tyhjä, alkiota ei ole varmasti puussa, ja metodi palauttaa heti `False`. Muuten metodi etsii alkiota juuresta alkaen samaan tapaan kuin lisäämisessä. Jos alkio löytyy jossain vaiheessa, metodi palauttaa `True`. Jos haku etenee puun ulkopuolelle, metodi palauttaa lopuksi `False`.

### String representation

The following method `__repr__` constructs a string representation of the set, which contains the elements of the set as a list.

Seuraava metodi `__repr__` muodostaa joukon merkkijonoesityksen, joka sisältää joukon alkiot listana.

```python
    def __repr__(self):
        items = []
        self.traverse(self.root, items)
        return str(items)

    def traverse(self, node, items):
        if not node:
            return
        self.traverse(node.left, items)
        items.append(node.value)
        self.traverse(node.right, items)
```

The method `__repr__` uses the method `traverse` that visits all nodes of the tree and adds their elements to the list. The traversal visits first all nodes in the left subtree, then adds the element in the node to the list, and then visits the nodes in the right subtree. This ensures that the elements are added to the list in the order of their value.

Metodi `__repr__` hyödyntää metodia `traverse`, joka käy läpi puun alkiot ja lisää ne listalle. Metodi käy ensin läpi vasemman alipuun, lisää sitten solmun alkion listalle ja käy sen jälkeen vielä läpi oikean alipuun. Tämän ansiosta lista sisältää lopuksi joukon alkiot suuruusjärjestyksessä.

### Other operations

This implementation does not yet have methods for finding the smallest and the largest elements or for removing an element. The implementation of these methods is a part of the exercises fot this week.

Tässä toteutuksessa ei ole vielä metodeja pienimpien ja suurimpien alkioiden etsimiseen eikä alkion poistamiseen. Näiden metodien toteuttaminen kuuluu tämän viikon tehtäviin.

## Balanced trees

The operations on binary search trees follow a route from the root of the tree down towards the leafs of the tree. The efficiency of the tree depends on how long these routes can be. The length of the longest possible route is equal to the height of the tree $$h$$. Thus the time complexity of the operations can be stated to be $$O(h)$$.

An arbitrary binary search tree is not necessarily an efficient data structure, because the tree can be tall. For example, if we add $$n$$ elements into the tree in the order $$1,2,\dots,n$$, all element go into a single chain and the height of the tree is $$n-1$$. Then the time complexity of the tree operations is $$O(n)$$.

Binäärihakupuun operaatiot käyvät läpi reittejä puun juuresta puun lehtiin. Tämän vuoksi puun tehokkuus riippuu siitä, miten pitkiä nämä reitit voivat olla. Pisimmän reitin pituus on yhtä suuri kuin puun korkeus $$h$$, joten binäärihakupuun operaatioiden tehokkuus voidaan ilmoittaa muodossa $$O(h)$$.

Binäärihakupuu ei sellaisenaan ole vielä tehokas tietorakenne, koska puun korkeus saattaa olla suuri. Esimerkiksi jos puuhun lisätään $$n$$ alkiota järjestyksessä $$1,2,\dots,n$$, kaikki alkiot menevät samaan ketjuun ja puun korkeus on $$n-1$$. Tällöin puun operaatiot vievät aikaa $$O(n)$$.

However, it is possible to implement a binary search tree so that elements are distributed evenly to the left and to the right, and the height of the tree is always of order $$\log n$$. Then the tree operations are efficient with time complexity $$O(\log n)$$. Such a binary search tree is called _balanced_.

Kuitenkin binäärihakupuu voidaan toteuttaa niin, että alkiot jakautuvat tasaisesti puun eri puolille ja puun korkeus on aina luokkaa $$\log n$$. Tällöin puun operaatiot toimivat tehokkaasti ja vievät aikaa vain $$O(\log n)$$. Tällaista binäärihakupuuta kutsutaan _tasapainoiseksi_ (_balanced_).

A balanced binary search tree is implemented so that the height of the tree is never too big. For example, an [AVL tree](../avlpuu) is a balanced binary search tree, where the heights of the left subtree and the right subtree of the same node cannot differ by more than $$1$$. This condition ensures that the height of the tree is always of order $$\log n$$. To maintain that condition, the structure of the tree is modified with rotations when necessary.

Tasapainoinen binäärihakupuu on toteutettu niin, ettei puun korkeus kasva liian suureksi. Esimerkiksi [AVL-puu](../avlpuu) on tasapainoinen binäärihakupuu, jossa jokaisen solmun vasemman ja oikean alipuun korkeuksien ero saa olla enintään $$1$$. Tämän ehdon ansiosta puun korkeus on aina luokkaa $$\log n$$. Jotta ehto säilyisi voimassa, puun rakennetta muutetaan tarvittaessa alipuiden kiertojen avulla.

## Example: Hotel

The following is an example of a problem that can be solved efficiently using a binary search tree:

Seuraavassa on esimerkki tehtävästä, joka voidaan ratkaista tehokkaasti binäärihakupuun avulla:

{: .note-title }
Task
<div class="note" markdown="1">

A hotel has $$n$$ rooms, each of which has a certain capacity (number of people). The hotel receives $$m$$ groups of visitors. Your task is to process the groups in order from left to right, and assign to each group the smallest room with sufficient capacity for the whole group, or report that no suitable room is available.

For example, suppose the room capacities are $$[2,4,4,8]$$ and the group sizes are $$[4,6,2,5,2]$$. Then the desired answer is $$[4,8,2,0,4]$$ ($$0$$ means that no room was assigned):

* The first group gets a room with capacity $$4$$.
* The second group gets a room with capacity $$8$$.
* The third group gets a room with capacity $$2$$.
* The fourth group does not get a room.
* The fifth group gets a room with capacity $$4$$.

Hotellissa on $$n$$ huonetta, joihin jokaiseen mahtuu tietty määrä ihmisiä. Hotelliin saapuu $$m$$ ryhmää asiakkaita. Sinun tulee käsitellä ryhmät järjestyksessä vasemmalta oikealle ja antaa jokaiselle ryhmälle pienin huone, johon he kaikki mahtuvat, tai ilmoittaa, ettei sopivaa huonetta ole saatavilla.

Esimerkiksi oletetaan että huoneiden koot ovat $$[2,4,4,8]$$ ja ryhmien koot ovat $$[4,6,2,5,2]$$. Tässä tapauksessa haluttu tulos on $$[4,8,2,0,4]$$ seuraavan mukaisesti ($$0$$ tarkoittaa, ettei ryhmä saanut huonetta):

* Ensimmäinen ryhmä saa huoneen, jonka koko on $$4$$.
* Toinen ryhmä saa huoneen, jonka koko on $$8$$.
* Kolmas ryhmä saa huoneen, jonka koko on $$2$$.
* Neljäs ryhmä ei saa huonetta.
* Viides ryhmä saa huoneen, jonka koko on $$4$$.

</div>

Assume that we can use a class `TreeSet` with the following methods:

* `add(x)`: adds the element `x` to the set
* `next(x)`: returns the smallest element that is larger than `x` (or `None` if there is no such element)
* `remove(x)`: removes the element `x` from the set

The task can be solved using these methods as follows:

Oletetaan, että käytössä on luokka `TreeSet`, jossa on seuraavat metodit:

* `add(x)`: lisää alkio `x` joukkoon
* `next(x)`: palauta pienin alkio, joka on suurempi kuin `x` (tai `None` jos alkiota ei ole olemassa)
* `remove(x)`: poista alkio `x` joukosta

Näiden metodien avulla tehtävä voidaan ratkaista seuraavasti:

```python
def find_rooms(sizes, requests):
    rooms = TreeSet()
    counter = 0
    for size in sizes:
        counter += 1
        rooms.add((size, counter))
        
    result = []
    for request in requests:
        room = rooms.next((request, 0))
        if room == None:
            result.append(0)
        else:
            rooms.remove(room)
            result.append(room[0])
            
    return result        
```

The function creates a set `rooms` and adds all available rooms to the set. Since multiple rooms can have the same capacity but the set cannot contain the same element multiple times, each room is represented as a pair, where the first part is the room capacity and the second is a unique room number. In the example case, the pairs `(2, 1)`, `(4, 2)`, `(4, 3)` and `(8, 4)` are added to the set.

Then the function goes through the groups and searches for a suitable room using the method `next`. The parameter for the method `next` is the pair `(request, 0)`, where `request` is the size of the group. Since `0` is smaller than any room number, the method finds the smallest room with a capacity at least `request`.

The time complexity of the function is $$O(n \log n + m \log n)$$ assuming that the binary search tree is balanced so that the tree operations take $$O(\log n)$$ time.

Funktio luo joukon `rooms` ja lisää sinne kaikki saatavilla olevat huoneet. Koska usealla huoneella voi olla sama koko mutta joukossa voi esiintyä vain kerran sama alkio, jokainen huone lisätään parina, jossa ensimmäinen alkio on huoneen koko ja toinen alkio on laskurin antama huoneen numero. Esimerkin tapauksessa joukkoon lisätään parit `(2, 1)`, `(4, 2)`, `(4, 3)` ja `(8, 4)`.

Tämän jälkeen funktio käy läpi ryhmien koot ja lisää listalle `result` tiedot kunkin ryhmän saaman huoneen koosta. Metodilla `next` etsitään pienin alkio, joka on suurempi kuin `(request, 0)`. Koska minkään huoneen numero ei ole `0`, metodi löytää pienimmän huoneen, jonka koko on ainakin `request`.

Funktio vie aikaa $$O(n \log n + m \log n)$$ olettaen, että binäärihakupuu on tasapainoinen ja sen operaatiot vievät aikaa $$O(\log n)$$.

## Why not in Python?

Many programming languages offer an implementation of a binary search tree, but the Python standard library does not. Why is this?

The likely explanation is that the Python developers did not consider the binary search tree to be so frequently needed data structure that it should be in the standard library. Python relies on hashing-based data structures (`set` and `dict`), which are sufficient for most purposes.

Binäärihakupuu on saatavilla valmiina monissa ohjelmointikielissä, mutta se puuttuu Pythonin standardikirjastosta. Miksi näin on?

Syy lienee siinä, että Pythonin kehittäjien näkemyksen mukaan binäärihakupuu ei ole niin usein tarvittava tietorakenne, että sen tulisi olla kielen standardikirjastossa. Pythonissa keskeisessä asemassa ovat hajautukseen perustuvat tietorakenteet (`set` ja `dict`), jotka riittävät monissa tapauksissa.

Indeed, hashing as well as sorting and a heap are alternatives to a binary search tree. In many tasks, one of the efficient solutions is to use a binary search tree, but often there are other efficient solutions without binary search trees.

If a binary search tree is needed, there are many implementation outside the standard library. Using these might be a better alternative than iplementing your own binary search tree.

Usein binäärihakupuun sijasta voidaan käyttää juuri hajautusta ja mahdollisesti lisäksi järjestämistä tai kekoa. Monissa tehtävissä yksi mahdollinen tehokas ratkaisu on käyttää binäärihakupuuta, mutta tehtävän voi ratkaista myös jotenkin muulla tavalla tehokkaasti ilman binäärihakupuuta.

Jos kuitenkin Pythonissa tarvitsee binäärihakupuuta, saatavilla on monia valmiita standardikirjaston ulkopuolisia toteutuksia. Näiden käyttäminen voi olla järkevämpää kuin itse toteutetun binäärihakupuun käyttäminen.

## Other progamming languages

In C++, the data structures ``std::set`` and ``std::map`` implement a set and a dictionary using a binary search tree. For example, the following code creates a set, adds element with the function `insert` and search for a successor using the function `upper_bound`.

C++:ssa tietorakenteet ``std::set`` ja ``std::map`` toteuttavat binäärihakupuuhun perustuvan joukon ja hakemiston. Esimerkiksi seuraava koodi luo joukon, lisää sinne funktiolla `insert` sekä etsii funktiolla `upper_bound` pienimmän annettua alkiota suuremman alkion.

```cpp
std::set<int> items;

items.insert(1);
items.insert(3);
items.insert(6);
items.insert(8);

auto it = items.upper_bound(4);
std::cout << *it << "\n"; // 6
```

Java has similar data structures `TreeSet` and `TreeMap`. For example, the following code corresponds to the above C++ code. 

Javassa vastaavat tietorakenteet ovat `TreeSet` ja `TreeMap`. Esimerkiksi seuraava koodi vastaa äskeistä C++-koodia:

```java
TreeSet<Integer> items = new TreeSet<>();

items.add(1);
items.add(3);
items.add(6);
items.add(8);

int item = items.higher(4);
System.out.println(item); // 6
```

JavaScript, similarly to Python, does not have a standard library implementation of binary search trees.

JavaScript noudattaa Pythonin linjaa siinä, että kielen standardikirjastossa ei ole binäärihakupuun toteutusta.
