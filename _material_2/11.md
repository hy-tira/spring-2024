---
title: 11. More data structures
slug: osa11
hide: true
sections:
  - Deque
  - Stack and queue
  - Heap
  - "Example: Sliding window"
  - Other programming languages
---

# 11. More data structures

This chapter covers two data structures:

* _Deque_: Deque is a list structure that supports efficient addition and removal of elements both at the beginning and at the end of the list.
* _Heap_: Heap is a data structure where the smallest or the largest element can be found and removed efficiently.

Both data structures are available in the Python standard library and are thus easy to use in Python programming. 

Tässä luvussa tutustumme kahteen tietorakenteeseen:

* _Pakka_ (_deque_): Pakka on listarakenne, jossa alkioiden lisäykset ja poistot ovat tehokkaita sekä listan alussa että lopussa.
* _Keko_ (_heap_): Keko on tietorakenne, jossa pystyy lisäämään tehokkaasti alkioita sekä etsimään ja poistamaan pienimmän tai suurimman alkion.

Molemmat tietorakenteet ovat saatavilla Pythonin standardikirjastossa, minkä ansiosta niitä voi käyttää kätevästi Python-ohjelmoinnissa.

## Deque

With the standard Python list, we can efficiently add an element to the end of a list using the method `append` and remove an element from the end of the list using the method `pop`. However, there is no efficient way of adding or removing an element at the beginning of the list.

_Deque_ is a list-like structure where additions and removals at both ends of the list are efficient. In Python, deque is available in the module `collections` and has the following methods:

* `append`: add an element to the end of the list
* `pop`: remove an element from the end of the list
* `appendleft`: add an element to the beginning of the list
* `popleft`: remove an element from the beginning of the list

Pythonin tavallisessa listassa on tehokasta lisätä alkio listan loppuun metodilla `append` sekä poistaa alkio listan lopusta metodilla `pop`. Kuitenkaan ei ole tehokasta tapaa lisätä tai poistaa alkiota listan alussa.

_Pakka_ (_deque_) on listarakenne, jossa lisäykset ja poistot ovat tehokkaita sekä listan alussa että lopussa. Pythonissa pakka on saatavilla moduulissa `collections` tietorakenteena `deque`, joka tarjoaa seuraavat metodit:

* `append`: lisää alkio listan loppuun
* `pop`: poista alkio listan lopusta
* `appendleft`: lisää alkio listan alkuun
* `popleft`: poista alkio listan alusta

In addition to the familiar methods `append` and `pop, we now have the methods `appendleft` and `popleft` that operate at the beginning of the list. All the time complexity of all four methods is $$O(1)$$.

The following code illustrates the use of a deque:

Tuttujen metodien `append` ja `pop` lisäksi pakassa on siis myös metodit `appendleft` ja `popleft`, joilla voi lisätä ja poistaa alkion listan alussa. Kaikkien näiden metodien aikavaativuus on $$O(1)$$.

Seuraava koodi esittelee pakan käyttämistä:

```python
import collections

items = collections.deque()

items.append(1)
items.append(2)
items.appendleft(3)
items.append(4)
items.appendleft(5)

print(items) # deque([5, 3, 1, 2, 4])

print(items[0]) # 5
print(items[1]) # 3
print(items[-1]) # 4
```

As the code shows, the elements of a deque can be accessed using the indexing operator `[]` similarly to the standard list. However, an access to an element in a deque is not always efficient, which is the biggest weakness of the deque. In the standard list any element can be accessed in $$O(1)$$ time, but an access to an element in the middle of a deque takes $$O(n)$$ time.

In Python, a deque is implemented using a [linked list](../linkitetty-lista), which enables the efficient additions and removals at both ends.

Pakkaa voi indeksoida samaan tapaan kuin tavallista listaa. Pakan heikkoutena on kuitenkin, että alkion käsittely indeksin perusteella on hidasta. Tavallisessa listassa missä tahansa indeksissä olevaan alkioon pääsee käsiksi ajassa $$O(1)$$, mutta pakassa listan keskellä olevan alkion käsittely vie aikaa $$O(n)$$.

Pakka on toteutettu Pythonissa [linkitettynä listana](../linkitetty-lista), minkä ansiosta on mahdollista lisätä ja poistaa alkioita tehokkaasti sekä listan alussa että lopussa.

## Stack and queue

_Stack_ is a data structure that supports adding and removing elements at the end of a list. _Queue_ is a data structure that supports adding elements to end end of a list and removing elements from the beginning of the list.

We can use a deque to implement both a stack and a queue, since operations at both ends are efficient. The following classes implement the stack and the queue:

_Pino_ (_stack_) on tietorakenne, jossa pystyy lisäämään alkion listan loppuun sekä hakemaan tai poistamaan alkion listan lopusta. _Jono_ (_queue_) on puolestaan tietorakenne, jossa pystyy lisäämään alkion listan loppuun sekä hakemaan tai poistamaan alkion listan alusta.

Pakan avulla pystyy toteuttamaan tehokkaasti sekä pinon että jonon, koska alkioita voi käsitellä tehokkaasti sekä listan alussa että lopussa. Seuraavat luokat `Stack` ja `Queue` toteuttavat pinon ja jonon:

```python
import collections

class Stack:
    def __init__(self):
        self.stack = collections.deque()

    def push(self, x):
        self.stack.append(x)

    def top(self):
        return self.stack[-1]

    def pop(self):
        self.stack.pop()

class Queue:
    def __init__(self):
        self.queue = collections.deque()

    def push(self, x):
        self.queue.append(x)

    def top(self):
        return self.queue[0]

    def pop(self):
        self.queue.popleft()
```

Notice that we could use the standard list to implement a stack as we did in Chapter 6. However, the implementation of a queue benefits from the efficient operations at both ends of a deque.

Huomaa, että pinon voi toteuttaa helposti myös Pythonin tavallisen listan avulla, kuten teimme luvussa 6. Sen sijaan jonon toteutuksessa on aitoa hyötyä siitä, että pakkaa pystyy käsittelemään tehokkaasti sekä alussa että lopussa.

## Heap

_Heap_ is a data structure that supports adding, accessing and removing elements. Additions to a heap are unrestricted, but depending on the implementation of a heap, either only the smallest or only the largest element of a heap can be accessed and removed.

In Python, a list can be used as a heap with the following functions in the module `heapq`: 

_Keko_ (_heap_) on tietorakenne, jossa voi lisätä, hakea ja poistaa alkioita. Kekoon voi lisätä alkioita rajoituksetta, mutta siitä voi hakea ja poistaa vain pienimmän tai suurimman alkion, riippuen keon toteutuksesta.

Pythonissa moduuli `heapq` sisältää funktioita, joiden avulla listaa voi käsitellä kekona:

* `heappush`: lisää kekoon uusi alkio
* `heappop`: poista ja palauta keon pienin alkio

The time complexity of both functions is $$O(\log n)$$. In addition, the smallest element in the list is always at the beginning of the list and can be accessed in $$O(1)$$ time.

The following code illustrates using a heap in Python:

Molemmat funktiot toimivat ajassa $$O(\log n)$$. Lisäksi listan ensimmäinen alkio on aina keon pienin alkio, joten sen pystyy hakemaan ajassa $$O(1)$$.

Seuraava koodi esittelee keon käyttämistä Pythonissa:

```python
import heapq

items = []

heapq.heappush(items, 4)
heapq.heappush(items, 2)
heapq.heappush(items, 3)
heapq.heappush(items, 1)
heapq.heappush(items, 5)

print(items[0]) # 1
heapq.heappop(items)
print(items[0]) # 2
```

Compared to hashing, the advantage of a heap is the efficient access and removal of the smallest or the largest element. With hashing this is not possible because a hash table does not store the elements in order. On the other hand, a heap does not support access to any other element than the smallest or the largest.

Notice a heap may contain multiple copies of an element. For example, the following code adds three copies of the number $$1$$ to a heap:

Verrattuna hajautukseen keon etuna on, että siitä pystyy hakemaan ja poistamaan pienimmän tai suurimman alkion tehokkaasti. Hajautuksessa tämä ei ole mahdollista, koska alkioita ei ole järjestetty. Toisaalta keon heikkoutena on, että ei ole mahdollista etsiä keosta tehokkaasti muita kuin pienin tai suurin alkio.

Huomaa, että sama alkio voi esiintyä keossa monta kertaa. Esimerkiksi seuraava koodi lisää kekoon kolmesti luvun $$1$$:

```python
import heapq

items = []
heapq.heappush(items, 1)
heapq.heappush(items, 1)
heapq.heappush(items, 1)

print(items) # [1, 1, 1]
```

The functions in the module `heapq` keep the elements of a list in a [specific order](../keko) so that the operations can be implemented efficiently.

Moduulin `heapq` funktiot pitävät listan alkioita [sopivassa järjestyksessä](../keko) niin, että keon operaatiot pystytään toteuttamaan tehokkaasti.

## Example: Sliding window

{: .note-title }
Task
<div class="note" markdown="1">

You are given a list of $$n$$ numbers and a parameter $$k$$. For each _sliding window_, i.e., a sublist of $k$ consecutive elements, from the left to right, find the smallest element in the sublist.

For example, when the list is $$[1,2,3,5,4,4,1,2]$$ and $$k=3$$, the desired answer is $$[1,2,3,4,1,1]$$. Here the sublists are $$[1,2,3]$$, $$[2,3,5]$$, $$[3,5,4]$$, $$[5,4,4]$$, $$[4,4,1]$$ and $$[4,1,2]$$.

Annettuna on lista, jossa on $$n$$ lukua, sekä parametri $$k$$. Laske vasemmalta oikealle jokaiselle _liukuvalle ikkunalle_ (_sliding window_) eli $$k$$ peräkkäisen luvun osalistalle, mikä on pienin osalistassa oleva luku.

Esimerkiksi kun lista on $$[1,2,3,5,4,4,1,2]$$ ja $$k=3$$, haluttu tulos on $$[1,2,3,4,1,1]$$. Tässä tapauksessa osalistat ovat $$[1,2,3]$$, $$[2,3,5]$$, $$[3,5,4]$$, $$[5,4,4]$$, $$[4,4,1]$$ ja $$[4,1,2]$$.

</div>

We can solve the task efficiently using a heap as follows:

Voimme ratkaista tehtävän tehokkaasti keon avulla seuraavasti:

```python
import heapq

def find_minima(items, k):
    n = len(items)
    heap = []
    result = []
    
    for i in range(n):
        heapq.heappush(heap, (items[i], i))
        while heap[0][1] <= i - k:
            heapq.heappop(heap)
        if i >= k - 1:
            result.append(heap[0][0])
            
    return result
```

The algorithm iterates through the list and adds pairs of form $$(x,i)$$ to the heap, where $$x$$ is the element at the position $$i$$. The smallest element in the heap can be accessed efficiently. If the smallest element is outside the current window, it is removed. Otherwise the smallest element is the desired answer for the current window.

The time complexity of the algorithm is $$O(n \log n)$$, because each element is added to and removed from the heap at most once.

Tämä algoritmi käy läpi listan ja lisää kekoon alkioita muotoa $$(x,i)$$: alkio $$x$$ on kohdassa $$i$$. Keosta voidaan hakea tehokkaasti pienin alkio, joka on kohdassa $$0$$. Lisäksi jos havaitaan, että keon pienin alkio on jäänyt listan ulkopuolelle, se poistetaan keosta.

Tuloksena olevan algoritmin aikavaativuus on $$O(n \log n)$$, koska jokainen alkio lisätään kekoon ja poistetaan keosta enintään kerran.

## Other programming languages

A deque can be implemented in different ways. The implementations in C++ and Java support efficient indexing of any element. In C++, the class `std::deque` implements the deque:

Pakan toteuttamiseen on useita tapoja, ja C++:n ja Javan toteutuksissa myös alkioiden indeksointi on tehokasta. C++:ssa luokka `std::deque` toteuttaa pakan:

```cpp
std::deque<int> items;

items.push_back(1);
items.push_back(2);
items.push_front(3);
items.push_back(4);
items.push_front(5);
```

Java has the class `ArrayDeque` based on an array:

Javassa on taulukkoon perustuva luokka `ArrayDeque`:

```java
ArrayDeque<Integer> items = new ArrayDeque<>();

items.addLast(1);
items.addLast(2);
items.addFirst(3);
items.addLast(4);
items.addFirst(5);
```

In many programming languages, heap is implemented under the name _priority queue_.  In C++, the class `std::priority_queue` implements a max heap:

Monissa kielissä kekoa käyttävän tietorakenteen nimi on _prioriteettijono_ (_priority queue_). C++:ssa luokka `std::priority_queue` toteuttaa maksimikeon:

```cpp
std::priority_queue<int> items;

items.push(1);
items.push(2);
items.push(3);

cout << items.top() << "\n"; // 3
items.pop();
cout << items.top() << "\n"; // 2
```

In Java, the class `PriorityQueue` implements a min heap:

Javassa luokka `PriorityQueue` toteuttaa minimikeon:

```java
PriorityQueue<Integer> items = new PriorityQueue<>();

items.add(1);
items.add(2);
items.add(3);

System.out.println(items.peek()); // 1
items.poll();
System.out.println(items.peek()); // 2
```
