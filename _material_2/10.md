---
title: 10. Dynaaminen ohjelmointi
slug: osa10
hide: true
sections:
  - Optimiratkaisun haku
  - Optimiratkaisun muodostus
  - Ratkaisujen laskeminen
  - "Esimerkki: Alijonot"
  - "Esimerkki: Sulkulausekkeet"
  - Sisäkkäinen rekursio
---

# 10. Dynamic programming

_Dynamic programming_ is an algorithmic technique that can be used for efficiently solving many search problems. In this chapter, we will learn about dynamic programming through the following problem:

_Dynaaminen ohjelmointi_ (_dynamic programming_) on algoritmitekniikka, jonka avulla voidaan ratkaista tehokkaasti monia hakuongelmia. Tutustumme tässä luvussa dynaamiseen ohjelmointiin seuraavan tehtävän kautta:

{: .note-title }
Task
<div class="note" markdown="1">

You have an unlimited number coins of values given as a list. Each value is a positive integer and the smallest value is $$1$$. The goal is to choose a set of coins summing up to $$x$$.

1. _Find the optimal solution_: How many coins at least is needed achieve the sum $$x$$?
2. _Construct an optimal solution_: Give an example of a minimal set of coins summing up $$x$$?
3. _Count solutions_: How many different ways there are to achieve the sum $$x$$ ?

Käytössäsi on rajaton määrä kolikkoja, joiden arvot annetaan listassa. Jokaisen kolikon arvo on positiivinen kokonaisluku ja pienin kolikko on arvoltaan $$1$$. Tavoitteena on muodostaa kolikoista summa $$x$$.

1. _Optimiratkaisun haku_: Montako kolikkoa tarvitaan vähintään summan $$x$$ muodostamiseen?
2. _Optimiratkaisun muodostus_: Anna esimerkki, miten summa $$x$$ voidaan muodostaa niin, että kolikoiden määrä on pienin.
3. _Ratkaisujen laskeminen_: Montako eri tapaa on muodostaa summa $$x$$ kolikoista?

For example, when the coin values are $$[1,2,5]$$ and $$x=13$$, the answers are:

1. The smallest number of coins needed is $$4$$.
2. A minimal solution is to choose the coins $$[1,2,5,5]$$.
3. There $$634$$ ways to choose the coins (including $$[1,2,5,5]$$, $$[2,2,2,2,5]$$ and $$[1,1,1,5,5]$$).

Esimerkiksi kun kolikot ovat $$[1,2,5]$$ ja $$x=13$$, vastaukset ovat:

1. Pienin määrä kolikoita on $$4$$.
2. Pienin ratkaisu saadaan valitsemalla kolikot $$[1,2,5,5]$$.
3. Erilaisia tapoja on $$634$$ (kuten $$[1,2,5,5]$$, $$[2,2,2,2,5]$$ ja $$[1,1,1,5,5]$$).

</div>

In the previous chapter, we saw an effcient solution using a greedy algorithm in the case where the coin values are $$[1,2,5]$$. However, the greedy algorithm does not work in all cases: For example, the algorithm may give a wrong answer when the coin values are $$[1,4,5]$$. Besides, the greedy algorithm cannot be used for solving the case 3 of the problem, where we want to count all solutions.

We will next look at how dynamic programming can be used for solving all cases efficiently. The techniques and ideas developed here are useful for solving many other problems too.

Edellisessä luvussa ratkaisimme tehtävän tehokkaasti ahneella algoritmilla tapauksessa, jossa kolikot ovat $$[1,2,5]$$. Ahne algoritmi ei kuitenkaan toimi kaikissa tapauksissa: esimerkiksi jos kolikot ovat $$[1,4,5]$$, algoritmi voi antaa väärän vastauksen. Lisäksi ahneella algoritmilla ei ole mahdollista ratkaista tehtävän kohtaa 3, jossa tulee laskea kaikkien tapojen määrä.

Näemme seuraavaksi, miten saamme ratkaistua tehtävän kaikki kohdat tehokkaasti dynaamisen ohjelmoinnin avulla. Tässä tehtävässä esille tulevia ideoita pystyy käyttämään myös muiden tehtävien ratkaisemisessa.

## Finding the optimal solution

The basic idea of dynamic programming is to solve a problem with the help of smaller cases of the same problem, called _subproblems_. For example, when we want to achieve the sum $$x$$ with coins, the subprolems are the cases where the target sum is $$0 \dots x-1$$.

Consider the example, where the coin values are $$[1,2,5]$$ and the target sum is $$x=13$$. We start the solution by choosing the first coin. There are three possibilities:

* Choose a coin of value $$1$$. Then the rest of the coins must sum up to $$x=12$$.
* Choose a coin of value $$2$$. Then the rest of the coins must sum up to $$x=11$$.
* Choose a coin of value $$5$$. Then the rest of the coins must sum up to $$x=8$$.
 
Dynaamisessa ohjelmoinnissa on ideana ratkaista ongelma saman ongelman pienempien tapausten eli _osaongelmien_ avulla. Esimerkiksi kun halutaan muodostaa summa $$x$$ kolikoista, osaongelmat ovat tapauksia, joissa halutaan muodostaa summat $$0 \dots x-1$$ kolikoista.

Tarkastellaan esimerkkiä, jossa halutaan muodostaa summa $$x=13$$ kolikoilla $$[1,2,5]$$. Voimme lähteä muodostamaan summaa $$x$$ valitsemalla ensimmäisen summaan kuuluvan kolikon. Vaihtoehdot ovat:

* Valitaan kolikko $$1$$. Tämän jälkeen tulee muodostaa summa $$x=12$$.
* Valitaan kolikko $$2$$. Tämän jälkeen tulee muodostaa summa $$x=11$$.
* Valitaan kolikko $$5$$. Tämän jälkeen tulee muodostaa summa $$x=8$$.

If we already know the smallest number of coins to achieve the sums $$x=8$$, $$x=11$$ and $$x=12$$, we can find the smallest number of coins summing up to $$x=13$$ by taking the smallest number of the three cases and adding one. Thus, in order to solve the case $$x=13$$, we need to first solve the three subproblems $$x=8$$, $$x=11$$ ja $$x=12$$. These subproblems can be solved similarly by dividing them into even smaller subproblems.

We can turn this idea into a practical dynamic programming algorithm by solving all the subproblems $$x=0,\dots,x$$ from the smallest to largest:

Jos tiedossa on pienin kolikoiden määrä tapauksille $$x=8$$, $$x=11$$ ja $$x=12$$, saamme pienimmän kolikoiden määrän tapaukselle $$x=13$$ valitsemalla näistä pienimmän ja lisäämällä tulokseen yhden. Niinpä seuraavaksi tulee ratkaista kolme osaongelmaa $$x=8$$, $$x=11$$ ja $$x=12$$. Nämä osaongelmat voi ratkaista samalla tavalla jakamalla ne edelleen pienempiin osaongelmiin.

Voimme toteuttaa dynaamisen ohjelmoinnin algoritmin käytännössä käymällä läpi osaongelmat pienimmästä suurimpaan:

```python
def min_coins(x, coins):
    result = {}
 
    result[0] = 0
    for s in range(1, x + 1):
        result[s] = s
        for c in coins:
            if s - c >= 0:
                result[s] = min(result[s], result[s - c] + 1)
 
    return result[x]
```

The function defines a dictionary 'result` that stores the smallest number of coins needed for each sum $$0 \dots x$$. The first step is to record the fact that the sum $$0$$ needs $$0$$ coins. Then the algorithm goes through all the other sums in a loop. For each sum, the smallest number of coins is computed as a minimum over all the possible ways of choosing the first coin.

Notice that, since one of the coin values is $$1$$, all the sums $$0 \dots x$$ can be formed using the coins. The initial value of `result[s]` is set to `s` which corresponds to choosing only coins of value $$1$$.

The function can be used as follows:

Funktio muodostaa sanakirjan `result`, johon tallennetaan jokaiselle summalle $$0 \dots x$$ pienin kolikoiden määrä, jolla summa voidaan muodostaa. Funktio merkitsee ensin, että summan $$0$$ muodostamiseen tarvitaan $$0$$ kolikkoa. Tämän jälkeen funktio laskee muiden tapausten vastaukset silmukalla. Jokaisen summan kohdalla funktio käy läpi kolikot ja valitsee vaihtoehdon, jossa kolikoiden määrä on pienin.

Huomaa, että koska yksi kolikoista on aina arvoltaan $$1$$, kaikki summat $$0 \dots x$$ voidaan muodostaa kolikoista. Silmukassa kohtaan `result[s]` asetetaan alkuarvo `s`, joka vastaa ratkaisua, jossa jokainen kolikko on $$1$$.

Funktiota voidaan käyttää näin:

```python
print(min_coins(13, [1, 2, 5])) # 4
print(min_coins(13, [1, 4, 5])) # 3
print(min_coins(42, [1, 5, 6, 17])) # 5
```
When $$x=13$$ and the coin values are $$[1,2,5]$$, the function computes the following answers:

Kun $$x=13$$ ja kolikot ovat $$[1,2,5]$$, funktio laskee seuraavat tulokset:

Sum $$x$$ | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13
Smallest number of coins | 0 | 1 | 1 | 2 | 2 | 1 | 2 | 2 | 3 | 3 | 2 | 3 | 3 | 4

This shows that the sum $$x=13$$ needs $$4$$ coins and all smaller sums need at most $$3$$ coins.

When $$x=13$$ and the coin values are $$[1,2,5]$$, the results are:

Tästä näkee, että summan $$x=13$$ muodostamiseen tarvitaan $$4$$ kolikkoa ja kaikissa pienemmissä tapauksissa riittää enintään $$3$$ kolikkoa.

Kun $$x=13$$ ja kolikot ovat $$[1,4,5]$$, tulokset ovat:

Summa $$x$$ | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13
Pienin määrä | 0 | 1 | 2 | 3 | 1 | 1 | 2 | 3 | 2 | 2 | 2 | 3 | 3 | 3

In this case, the greedy algorithm would produce a wrong answer, but the dynamic programming algorithm is correct, because it goes through all the ways of choosing the coins.

The time complexity of the algorithm is $$O(nx)$$, where $$n$$ is the number of coin values and $$x$$ is the target sum. This enables efficient computation even in fairly big cases, that would be far too big for a brute force algorithm.

Tässä tapauksessa ahne algoritmi ei antaisi oikeaa vastausta, mutta dynaamisen ohjelmoinnin algoritmi toimii, koska se käy läpi kaikki tavat valita kolikot.

Algoritmin aikavaativuus on $$O(nx)$$, missä $$n$$ on kolikoiden määrä ja $$x$$ on muodostettava summa. Tämän ansiosta voidaan käsitellä tehokkaasti myös suuria tapauksia, mikä ei olisi mahdollista raa'an voiman algoritmeilla.

## Constructing an optimal solution

Next we will expand the dynamic programming algorithm so that it produces the actual set of coins corresponding to the minimal solution. For example, when $$x=13$$ and the coin values are $$[1,2,5]$$, the algorithm should return the solution $$[1,2,5,5]$$ rather than just reporting that $$4$$ coins is needed.

We can implement the algorithm by storing the smallest set of coins for each sum $$0 \dots x$$ as a list. The length of each such list is the smallest number of number of coins needed for that sum. This can be implemented as follows:

Laajennetaan seuraavaksi dynaamisen ohjelmoinnin algoritmia niin, että se etsii pienimpään ratkaisuun tarvittavat kolikot. Esimerkiksi kun $$x=13$$ ja kolikot ovat $$[1,2,5]$$, algoritmin tulisi palauttaa ratkaisu $$[1,2,5,5]$$ eikä vain ilmoittaa, että pienimmässä ratkaisussa on $$4$$ kolikkoa.

Tällainen algoritmi voidaan toteuttaa tallentamalla jokaiselle summalle $$0 \dots x$$ lista kolikoista, joilla summa voidaan muodostaa ja jossa kolikoiden määrä on mahdollisimman pieni. Tällöin listan pituus on yhtä suuri kuin summaa $$x$$ vastaava pienin kolikoiden määrä. Tämä voidaan toteuttaa seuraavasti:

```python
def min_coins(x, coins):
    result = {}
 
    result[0] = []
    for s in range(1, x + 1):
        result[s] = [1] * s
        for c in coins:
            if s - c >= 0:
                new_result = result[s - c] + [c]
                if len(new_result) < len(result[s]):
                    result[s] = new_result
 
    return sorted(result[x])
```

Inside the inner loop, the algorithm constructs a list `new_list` from the list corresponding to the sum $$s - c$$. Appending a coin of value $$c$$ to the subproblem list produces the shortest list that sums up to $$s$$ and has $$c$$ as the last coin. If this list is shorter than any of the previous lists, it becomes the new minimal list for the sum $$s$$.

The function can be used as follows:

Silmukassa lista `new_result` muodostetaan ottamalla pohjaksi lyhin lista, jonka kolikot muodostavat summan $$s - c$$. Tämän listan perään lisätään kolikko $$c$$, jolloin saadaan lyhin lista, jonka kolikot muodostavat summan $$s$$ ja jossa viimeinen kolikko on $$c$$. Jos lista on aiempaa lyhempi, siitä tulee ratkaisu summalle $$s$$.

Funktiota voidaan käyttää näin:

```python
print(min_coins(13, [1, 2, 5])) # [1, 2, 5, 5]
print(min_coins(13, [1, 4, 5])) # [4, 4, 5]
print(min_coins(42, [1, 5, 6, 17])) # [1, 1, 6, 17, 17]
```

## Counting solutions

Dynamic programming can also be used for counting the number of all solutions. For example, when the coin values are $$[1,2,3]$$, there are $$634$$ different ways to choose a list of coins with the sum $$x=13$$. Here are some of the possible solutions:

Dynaamisen ohjelmoinnin avulla voidaan myös laskea, montako erilaista ratkaisua tehtävään on olemassa. Esimerkiksi kun $$x=13$$ ja kolikot ovat $$[1,2,5]$$, mahdollisia ratkaisuja on yhteensä $$634$$. Tässä on joitakin mahdollisia ratkaisuja:

* $$[1,2,5,5]$$ <span></span>
* $$[2,2,2,2,5]$$ <span></span>
* $$[1,1,1,5,5]$$ <span></span>
* $$[2,2,2,2,2,2,1]$$ <span></span>
* $$[1,1,1,1,1,1,1,1,1,1,1,1,1]$$ <span></span>

The number of solutions can be computed in a similar way as the minimal number of coins. The search can be implemented as follows:

Kaikkien ratkaisujen määrä voidaan etsiä melko samalla tavalla kuin pienimmän ratkaisun kolikkojen määrä. Haku voidaan toteuttaa seuraavasti:

```python
def count_coins(x, coins):
    result = {}
    
    result[0] = 1
    for s in range(1, x + 1):
        result[s] = 0
        for coin in coins:
            if s - coin >= 0:
                result[s] += result[s - coin]
                
    return result[x]
```

The difference to the earlier function `min_coins` is that the function takes a sum instead of a minimum. In the case $$x=0$$, the result is $$1$$, because there is exactly one way to achieve the sum $$0$$ (an empty list). In other cases, the function goes through all the ways of choosing the last coin, and adds up the results.

The function can be used as follows:

Erona aiempaan funktioon `min_coins` verrattuna on, että funktio laskee minimien sijasta summia. Tapauksessa $$x=0$$ tulos on $$1$$, koska on yksi tapa muodostaa summa $$0$$ (ei valita mitään kolikkoja). Muissa tapauksissa funktio käy läpi vaihtoehdot, mikä on summan viimeinen kolikko, ja laskee mukaan nämä tapaukset.

Funktiota voidaan käyttää näin:

```python
print(count_coins(13, [1, 2, 5])) # 634
print(count_coins(13, [1, 4, 5])) # 88
print(count_coins(42, [1, 5, 6, 17])) # 1103532
```

Notice that the function counts each different ordering of the list separately. For example, the lists $$[1,2,5,5]$$, $$[1,5,2,5]$$ and $$[1,5,5,2]$$ count as three different ways even though they consist of the same set of coins. Counting each combination of coins only once is a more difficult problem, but it too can be solved efficiently using dynamic programming.

Huomaa, että funktio laskee erikseen kaikki tavat järjestää kolikot listaan. Esimerkiksi funktio laskee erikseen mukaan ratkaisut $$[1,2,5,5]$$, $$[1,5,2,5]$$ ja $$[1,5,5,2]$$, vaikka ne muodostuvat samoista kolikoista. Vaikeampi tehtävä, joka on myös mahdollista ratkaista dynaamisella ohjelmoinnilla, on laskea mukaan jokainen samojen kolikoiden yhdistelmä vain kerran.

## Example: Subsequence

{: .note-title }
Task
<div class="note" markdown="1">

You are given a list of $$n$$ integers. Your task is to find how long is the _longest increasing subsequence_, i.e., how many numbers can we choose from the list going from left to right so that each number is larger than the previous number.

For example, in the list $$[4,1,5,6,3,4,1,8]$$, a longest increasing subsequence is $$[1,3,4,8]$$ and its length is $$4$$.

Annettuna on lista, jossa on $$n$$ kokonaislukua. Tehtäväsi on laskea, kuinka pitkä on listan _pisin nouseva alijono_ eli montako lukua listalta voidaan valita vasemmalta oikealle kulkien niin, että jokainen luku on edellistä suurempi.

Esimerkiksi listassa $$[4,1,5,6,3,4,1,8]$$ pisin nouseva alijono on $$[1,3,4,8]$$, jonka pituus on $$4$$.

</div>

We can use dynamic programming to solve this problem by computing for each position in the list the length of the longest increasing subsequence ending at that position. For the example, the lengths are:

Voimme lähestyä tehtävää dynaamisen ohjelmoinnin avulla laskemalla jokaiselle listan kohdalle, kuinka pitkä on pisin kyseiseen kohtaan päättyvä alijono. Esimerkissä laskettavat luvut ovat seuraavat:

List position | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
Length of subsequence | 1 | 1 | 2 | 3 | 2 | 3 | 1 | 4

For example, the longest increasing subsequence ending at the position $$5$$ is $$[1,3,4]$$ and its length is $$3$$.

The following function `find_longest` computes the length of the longest increasing subsequence by dynamic programming:

Esimerkiksi pisin kohtaan $$5$$ päättyvä alijono on $$[1,3,4]$$, jonka pituus on $$3$$.

Seuraava funktio `find_longest` etsii annetun listan pisimmän nousevan alijonon dynaamisen ohjelmoinnin avulla:

```python
def find_longest(items):
    result = {}

    max_len = 0
    for i in range(len(items)):
        result[i] = 1
        for j in range(i):
            if items[j] < items[i]:
                result[i] = max(result[i], result[j] + 1)
        max_len = max(max_len, result[i])

    return max_len
```

The function defines a dictionary `result` and fills it with the subsequence lengths for each position. The variable `i` goes through the list positions and the variable `j` goes through all the possible choices for the position of the previous number in the subsequence. If that previous number is smaller than the current number, the subsequence ending at the position `j` can be extended with the current number. The variable `max_len` keeps track of the length of the longest subsequence encountered so far.

The function can be used as follows:

Funktio luo sanakirjan `result` ja laskee siihen jokaiseen kohtaan pisimmän nousevan alijonon pituuden listassa. Muuttuja `i` käy läpi listan kohdat ja muuttuja `j` käy läpi mahdolliset kohdat, jossa on alijonon edellinen luku. Jos edellinen luku on pienempi kuin nykyinen luku, alijonoa voidaan laajentaa. Muuttujassa `max_len` pidetään yllä pisimmän alijonon pituutta.

Funktiota voidaan käyttää näin:

```python
print(find_longest([4, 1, 5, 6, 3, 4, 1, 8])) # 4
```

The time complexity of the algorithm is $$O(n^2)$$, because it has two nested loops. Since the number of all possible subsequences is $$O(2^n)$$, this algorithm is much faster than a brute force algorithm that iterates through all subsequences.

Tämän algoritmin aikavaativuus on $$O(n^2)$$, koska siinä on kaksi sisäkkäistä silmukkaa. Koska kaikkien alijonojen määrä on $$O(2^n)$$, tämä on merkittävä tehostus verrattuna siihen, että kaikki alijonot käytäisiin läpi.

## Example: Balanced parenthesis

Sometimes turning an inefficient brute force solution into an efficient dynamic programming solution is surprisingly easy. This is the case in the following problem: 

Joskus raa'an voiman ratkaisu on yllättävän helppoa muuttaa dynaamisen ohjelmoinnin ratkaisuksi. Näin on seuraavassa tehtävässä:

{: .note-title }
Tehtävä
<div class="note" markdown="1">

Sulkulauseke on suluista `(` ja `)` muodostuva merkkijono, joka vastaa oikein muodostettua matemaattista kaavaa. Tehtäväsi on laskea, montako sulkulauseketta voidaan muodostaa $$n$$ merkistä.

Esimerkiksi kun $$n=6$$, haluttu vastaus on $$5$$, koska mahdolliset sulkulausekkeet ovat `((()))`, `(())()`, `()(())`, `(()())` ja `()()()`.

</div>

In the previous chapter, we saw the following brute force solution:

Edellisessä luvussa ratkaisimme tehtävän raa'an voiman avulla näin:

```python
def count_sequences(n, d=0):
    if d < 0 or d > n:
        return 0
    if n == 0:
        return 1
    return count_sequences(n - 1, d + 1) + \
           count_sequences(n - 1, d - 1)
```

This algorithm can be changed into an efficient dynamic programming algorithm by storing the function results into a dictionary:

Tämän ratkaisun voi muuttaa tehokkaaksi dynaamisen ohjelmoinnin ratkaisuksi tallentamalla funktion tulokset muistiin sanakirjaan:

```python
def count_sequences(n, d=0, result={}):
    if d < 0 or d > n:
        return 0
    if n == 0:
        return 1
    if (n, d) not in result:
        result[(n, d)] = count_sequences(n - 1, d + 1) + \
                         count_sequences(n - 1, d - 1)
    return result[(n, d)]
```

In this case, the dynamic programming subproblems are _pairs_ of the form $(n,d)$$, where $$n$$ is the number of additional parenthesis symbols needed, and $$d$$ is the parenthesis depth of the current sequence. The dictionary `result` contains the answers for all parameter combinations that have already been computed by earlier calls of the function. The answer is computed by recursion only if it has not been computed previously, and uses the answer stored in the dictionary otherwise.

The brute force function is usable only for small cases, but the dynamic programming supports much bigger cases. For example, we can count balanced parenthesis sequences of length $$n=100$$:

Tässä tapauksessa dynaamisen ohjelmoinnin osaongelmat ovat _pareja_ muotoa $$(n,d)$$, missä $$n$$ on lisättävien sulkujen määrä ja $$d$$ on muodostetun lausekkeen syvyys. Sanakirja `result` sisältää vastaukset kaikille parametrien yhdistelmille, jotka funktio on jo laskenut. Funktio laskee vastauksen rekursiivisesti vain, jos sitä ei ole laskettu aiemmin, ja hakee vastauksen muuten suoraan sanakirjasta.

Alkuperäinen raa'an voiman funktio soveltui vain pienten tapausten laskemiseen, mutta dynaamisen ohjelmoinnin ansiosta voimme laskea myös suuria tapauksia. Esimerkiksi voimme laskea sulkulausekkeiden määrän, kun $$n=100$$:

```python
print(count_sequences(100)) # 1978261657756160653623774456
```

Since each call of the function needs $$O(1)$$ time and the number of parameter combinations is $$O(n^2)$$, the time complexity of the algorithm is $$O(n^2)$$.

There is another way of solving this problem using dynamic programming so that the function only takes one parameter $$n$$:

Koska jokainen funktion kutsu vie aikaa $$O(1)$$ ja erilaisia parametrien yhdistelmiä on $$O(n^2)$$, algoritmin aikavaativuus on $$O(n^2)$$.

Tämä tehtävä on mahdollista ratkaista myös toisella tavalla dynaamisella ohjelmoinnilla niin, että funktiolla on pelkkä parametri $$n$$:

```python
def count_sequences(n, result={}):
    if n == 0:
        return 1
    if n not in result:
        count = 0
        for i in range(2, n + 1, 2):
            count += count_sequences(i - 2) * \
                     count_sequences(n - i)
        result[n] = count
    return result[n]
```

The idea is to go through all possible ways for the position of the closing paranthesis `)` matching the first opening opening parenthesis `)`. For each such choice, both the sequence between the pair of parenthesis and the sequence after the closing parenthesis must be balanced parenthesis sequences, and the sequence count for the choice can be obtained as a product of the sequence counts for the between and after sequences.

In this algorithm, each function call takes $$O(n)$$ time and the number of parameter combinations is $$O(n)$$. Thus the time complexity of this algorithm too is $$O(n^2)$$, even though the algorithm logic is quite different.

Tässä ideana on käydä läpi kaikki tavat valita kohta, jossa on ensimmäistä alkusulkua `(` vastaava loppusulku `)`. Jokaisessa tavassa näiden sulkujen väliin sekä näiden sulkujen jälkeen tulee jokin sulkulauseke, minkä ansiosta lausekkeiden määrä saadaan kertomalla väliin ja jälkeen tulevien lausekkeiden määrät.

Tässä algoritmissa jokainen funktion kutsu vie aikaa $$O(n)$$ ja erilaisia parametrien yhdistelmiä on $$O(n)$$. Myös tämän algoritmin aikavaativuus on siis $$O(n^2)$$, vaikka algoritmien logiikka on hyvin erilainen.

## Nested recursion

Implementing a dynamic programming algorithm with recursion can lead to deeply nested recursive calls, which can cause problems when executing the code. For example, the following code does not work as desired:

Rekursiolla toteutettu dynaaminen ohjelmointi voi aiheuttaa paljon sisäkkäistä rekursiota, mikä voi aiheuttaa ongelman koodin suorittamiseen. Esimerkiksi seuraava koodi ei toimi toivotulla tavalla:

```python
print(count_sequences(2000)) # ?
```

The execution of the code causes an error "RecursionError: maximum recursion depth exceeded in comparison", which means that there are too many nested recursive calls.

In Python, the limit for nested recursive calls is fairly small, for example 1000. However, the limit can be raised using the function `setrecursionlimit` in the module `sys` as follows:

Koodin suoritus aiheuttaa virheen "RecursionError: maximum recursion depth exceeded in comparison" mikä tarkoittaa, että funktiota `count_sequences` kutsutaan liian monta kertaa rekursiivisesti.

Pythonissa sisäkkäisten rekursiokutsujen raja on usein oletuksena melko pieni, esimerkiksi 1000. Rajaa voidaan kuitenkin nostaa moduulin `sys` funktiolla `setrecursionlimit` seuraavasti:

```python
import sys
sys.setrecursionlimit(5000)
```

Now above code can be executed successfully:

Tämän jälkeen koodin suorittaminen onnistuu:

```python
print(count_sequences(2000)) # 2046105521468021692642519982997827217179245642339057975844538099572176010191891863964968026156453752449015750569428595097318163634370154637380666882886375203359653243390929717431080443509007504772912973142253209352126946839844796747697638537600100637918819326569730982083021538057087711176285777909275869648636874856805956580057673173655666887003493944650164153396910927037406301799052584663611016897272893305532116292143271037140718751625839812072682464343153792956281748582435751481498598087586998603921577523657477775758899987954012641033870640665444651660246024318184109046864244732001962029120
```

However, changing the recursion limit can be problematic, because it can cause issues with the Python execution environment. Another approach is to modify the dynamic programming implementation so that it uses loops instead of recursion. Consider the following implementation: 

Rekursiorajan kasvattaminen voi kuitenkin olla kyseenalainen ratkaisu, koska se saattaa aiheuttaa ongelmia Pythonin suoritusympäristössä. Toinen ratkaisu on muuttaa dynaamisen ohjelmoinnin toteutusta niin, että rekursion sijasta käytetäänkin silmukoita. Tarkastellaan esimerkkinä seuraavaa toteutusta:

```python
def count_sequences(n, d=0, result={}):
    if d < 0 or d > n:
        return 0
    if n == 0:
        return 1
    if (n, d) not in result:
        result[(n, d)] = count_sequences(n - 1, d + 1) + \
                         count_sequences(n - 1, d - 1)
    return result[(n, d)]
```

We can remove the recursion by finding a suitable order for computing the subproblems so that when a subproblem result is needed, it has already been computed and stored in the dictionary `result`. In this case, we can implement the function as follows:

Rekursio voidaan poistaa miettimällä, missä järjestyksessä funktio lisää osaongelmien vastaukset sanakirjaan `result`, ja toteuttamalla sitten vastaavan laskennan ilman rekursiota. Tässä tapauksessa laskenta voidaan toteuttaa näin:

```python
def count_sequences(n):
    result = {}
    result[(0, 0)] = 1
    for i in range(1, n + 1):
        result[(0, i)] = 0
    for i in range(1, n + 1):
        for j in range(0, n + 1):
            result[(i, j)] = 0
            if j + 1 <= n:
                result[(i, j)] += result[(i - 1, j + 1)]
            if j - 1 >= 0:
                result[(i, j)] += result[(i - 1, j - 1)]
    return result[(n, 0)]
```

The advantage of this implementation is that it does not use recursion and has no problems with the recursion limit. The disadvantage is that the code is slightly more complicated because the order of computing the subproblems must be designed and implemented explicitly rather than left for the recursion to handle. 

Tämän toteutuksen etuna on, että siinä ei ole rekursiota eikä sitä käyttäessä tarvitse huolehtia Pythonin rekursiorajasta. Kuitenkin huonona puolena tällaisessa toteutuksessa täytyy suunnitella itse, missä järjestyksessä osaongelmat käsitellään, eikä sitä voi jättää rekursion vastuulle.











---
title: 10. Dynaaminen ohjelmointi
slug: osa10
hide: true
sections:
  - Optimiratkaisun haku
  - Optimiratkaisun muodostus
  - Ratkaisujen laskeminen
  - "Esimerkki: Alijonot"
  - "Esimerkki: Sulkulausekkeet"
  - Sisäkkäinen rekursio
---

# 10. Dynaaminen ohjelmointi

_Dynaaminen ohjelmointi_ (_dynamic programming_) on algoritmitekniikka, jonka avulla voidaan ratkaista tehokkaasti monia hakuongelmia. Tutustumme tässä luvussa dynaamiseen ohjelmointiin seuraavan tehtävän kautta:

{: .note-title }
Tehtävä
<div class="note" markdown="1">

Käytössäsi on rajaton määrä kolikkoja, joiden arvot annetaan listassa. Tavoitteena on muodostaa kolikoista summa $$x$$.

1. _Optimiratkaisun haku_: Montako kolikkoa tarvitaan vähintään summan muodostamiseen?
2. _Optimiratkaisun muodostus_: Anna esimerkki ratkaisusta, jossa on pienin määrä kolikkoja.
3. _Ratkaisujen laskeminen_: Kuinka monta eri tapaa on muodostaa summa kolikoista?

Esimerkiksi kun kolikot ovat $$[1,2,5]$$ ja $$x=13$$, vastaukset ovat:

1. Pienin määrä kolikoita on $$4$$.
2. Pienin ratkaisu saadaan valitsemalla kolikot $$[1,2,5,5]$$.
3. Erilaisia tapoja on $$634$$ (kuten $$[1,2,5,5]$$, $$[2,2,2,2,5]$$ ja $$[1,1,1,5,5]$$).

</div>

Edellisessä luvussa ratkaisimme tehtävän tehokkaasti ahneella algoritmilla tapauksessa, jossa kolikot ovat $$[1,2,5]$$. Ahne algoritmi ei kuitenkaan toimi kaikissa tapauksissa: esimerkiksi jos kolikot ovat $$[1,4,5]$$, algoritmi voi antaa väärän vastauksen. Lisäksi ahneella algoritmilla ei ole mahdollista ratkaista tehtävän kohtaa 3, jossa tulee laskea kaikkien tapojen määrä.

Näemme seuraavaksi, miten saamme ratkaistua tehtävän kaikki kohdat tehokkaasti dynaamisen ohjelmoinnin avulla. Tässä tehtävässä esille tulevia ideoita pystyy käyttämään myös muiden tehtävien ratkaisemisessa.

## Optimiratkaisun haku

Dynaamisessa ohjelmoinnissa on ideana ratkaista ongelma saman ongelman pienempien tapausten eli _osaongelmien_ avulla. Esimerkiksi kun halutaan muodostaa summa $$x$$ kolikoista, osaongelmat ovat tapauksia, joissa halutaan muodostaa summat $$0 \dots x-1$$ kolikoista.

Tarkastellaan esimerkkiä, jossa halutaan muodostaa summa $$x=13$$ kolikoilla $$[1,2,5]$$. Voimme lähteä muodostamaan summaa $$x$$ valitsemalla ensimmäisen summaan kuuluvan kolikon. Vaihtoehdot ovat:

* Valitaan kolikko $$1$$. Tämän jälkeen tulee muodostaa summa $$x=12$$.
* Valitaan kolikko $$2$$. Tämän jälkeen tulee muodostaa summa $$x=11$$.
* Valitaan kolikko $$5$$. Tämän jälkeen tulee muodostaa summa $$x=8$$.

Jos tiedossa on pienin kolikoiden määrä tapauksille $$x=8$$, $$x=11$$ ja $$x=12$$, saamme pienimmän kolikoiden määrän tapaukselle $$x=13$$ valitsemalla näistä pienimmän ja lisäämällä tulokseen yhden. Niinpä seuraavaksi tulee ratkaista kolme osaongelmaa $$x=8$$, $$x=11$$ ja $$x=12$$. Nämä osaongelmat voi ratkaista samalla tavalla jakamalla ne edelleen pienempiin osaongelmiin.

Voimme toteuttaa dynaamisen ohjelmoinnin algoritmin käytännössä käymällä läpi osaongelmat pienimmästä suurimpaan:

```python
def min_coins(x, coins):
    result = {}
    
    result[0] = 0
    for s in range(1, x + 1):
        result[s] = float("inf")
        for coin in coins:
            if s - coin >= 0:
                result[s] = min(result[s], result[s - coin] + 1)
                
    return result[x]
```

Funktio muodostaa sanakirjan `result`, jossa on jokaiselle summalle $$0 \dots x$$ pienin kolikoiden määrä, jolla summa voidaan muodostaa. Funktio merkitsee ensin, että summan $$0$$ muodostamiseen tarvitaan $$0$$ kolikkoa. Tämän jälkeen funktio laskee muiden tapausten vastaukset silmukalla. Jokaisen summan kohdalla funktio käy läpi kolikot ja valitsee vaihtoehdon, jossa kolikoiden määrä on pienin.

Huomaa, että silmukassa vastauksen alkuarvo on `float("inf")` eli $$\infty$$ (ääretön). Tämän tarkoituksena on, että mikä tahansa todellinen kolikkojen määrä on pienempi ja korvaa tämän alkuarvon. Toisaalta jos summaa ei ole mahdollista muodostaa käytettävissä olevilla kolikoilla, arvoksi jää $$\infty$$.

Funktiota voidaan käyttää näin:

```python
print(min_coins(13, [1, 2, 5])) # 4
print(min_coins(13, [1, 4, 5])) # 3
print(min_coins(13, [2, 4, 5])) # 3
```

Kun $$x=13$$ ja kolikot ovat $$[1,2,5]$$, funktio laskee seuraavat tulokset:

Summa $$x$$ | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13
Pienin määrä | 0 | 1 | 1 | 2 | 2 | 1 | 2 | 2 | 3 | 3 | 2 | 3 | 3 | 4

Tästä näkee, että summan $$x=13$$ muodostamiseen tarvitaan $$4$$ kolikkoa ja kaikissa pienemmissä tapauksissa riittää enintään $$3$$ kolikkoa.

Kun $$x=13$$ ja kolikot ovat $$[1,4,5]$$, tulokset ovat:

Summa $$x$$ | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13
Pienin määrä | 0 | 1 | 2 | 3 | 1 | 1 | 2 | 3 | 2 | 2 | 2 | 3 | 3 | 3

Tässä tapauksessa ahne algoritmi ei antaisi oikeaa vastausta, mutta dynaamisen ohjelmoinnin algoritmi toimii, koska se käy läpi kaikki tavat valita kolikot.

Kun $$x=13$$ ja kolikot ovat $$[2,4,5]$$, tulokset ovat:

Summa $$x$$ | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13
Pienin määrä | 0 | $$\infty$$ | 1 | $$\infty$$ | 1 | 1 | 2 | 2 | 2 | 2 | 2 | 3 | 3 | 3

Tässä tapauksessa summia $$x=1$$ ja $$x=3$$ ei ole mahdollista muodostaa, minkä vuoksi niiden kohdalla tuloksena on $$\infty$$.

Algoritmin aikavaativuus on $$O(nx)$$, missä $$n$$ on kolikoiden määrä ja $$x$$ on muodostettava summa. Tämän ansiosta voidaan käsitellä tehokkaasti myös suuria tapauksia, mikä ei olisi mahdollista raa'an voiman algoritmeilla.

## Optimiratkaisun muodostus

Laajennetaan seuraavaksi dynaamisen ohjelmoinnin algoritmia niin, että se etsii pienimpään ratkaisuun tarvittavat kolikot. Esimerkiksi kun $$x=13$$ ja kolikot ovat $$[1,2,5]$$, algoritmin tulisi palauttaa ratkaisu $$[1,2,5,5]$$ eikä vain ilmoittaa, että pienimmässä ratkaisussa on $$4$$ kolikkoa.

Ratkaisun muodostaminen voidaan toteuttaa tallentamalla enemmän tietoa haun aikana. Seuraavassa funktiossa käytössä on sanakirja `best_choice`, johon tallennetaan kullekin summalle tieto, mikä kolikko tulee valita ensimmäisenä summaa muodostaessa.

```python
def min_coins(x, coins):
    result = {}
    best_choice = {}
    
    result[0] = 0
    for s in range(1, x + 1):
        result[s] = float("inf")
        for coin in coins:
            if s - coin >= 0:
                new_result = result[s - coin] + 1
                if new_result < result[s]:
                    result[s] = new_result
                    best_choice[s] = coin

    solution = []
    while x > 0:
        solution.append(best_choice[x])
        x -= best_choice[x]
    
    return solution
```

Kun funktio päivittää paremman tuloksen sanakirjaan `result`, se päivittää samalla myös valitun kolikon sanakirjaan `best_choice`. Tämän ansiosta silmukan jälkeen voidaan muodostaa ratkaisu katsomalla sanakirjasta `best_choice`, mikä kolikko milloinkin kannattaa valita.

Funktiota voidaan käyttää näin:

```python
print(min_coins(13, [1, 2, 5])) # [1, 2, 5, 5]
print(min_coins(13, [1, 4, 5])) # [4, 4, 5]
print(min_coins(42, [1, 5, 6, 17])) # [1, 1, 6, 17, 17]
```

Esimerkiksi kun $$x=13$$ ja kolikot ovat $$[1,2,5]$$, funktio laskee seuraavat tulokset:

Summa $$x$$ | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13
Pienin määrä | 0 | 1 | 1 | 2 | 2 | 1 | 2 | 2 | 3 | 3 | 2 | 3 | 3 | 4
Paras valinta | -- | 1 | 2 | 1 | 2 | 5 | 1 | 2 | 1 | 2 | 5 | 1 | 2 | 1

Tästä näkee, että kun $$x=13$$, paras valinta on kolikko $$1$$. Tämän jälkeen kun $$x=12$$, paras valinta on kolikko $$2$$. Sitten $$x=10$$ ja paras valinta on kolikko $$5$$, ja lopuksi $$x=5$$ ja paras valinta on taas kolikko $$5$$.

## Ratkaisujen laskeminen

Dynaamisen ohjelmoinnin avulla voidaan myös laskea, montako erilaista ratkaisua tehtävään on olemassa. Esimerkiksi kun $$x=13$$ ja kolikot ovat $$[1,2,5]$$, mahdollisia ratkaisuja on yhteensä $$634$$. Tässä on joitakin mahdollisia ratkaisuja:

* $$[1,2,5,5]$$ <span></span>
* $$[2,2,2,2,5]$$ <span></span>
* $$[1,1,1,5,5]$$ <span></span>
* $$[2,2,2,2,2,2,1]$$ <span></span>
* $$[1,1,1,1,1,1,1,1,1,1,1,1,1]$$ <span></span>

Kaikkien ratkaisujen määrä voidaan etsiä melko samalla tavalla kuin pienimmän ratkaisun kolikkojen määrä. Haku voidaan toteuttaa seuraavasti:

```python
def count_coins(x, coins):
    result = {}
    
    result[0] = 1
    for s in range(1, x + 1):
        result[s] = 0
        for coin in coins:
            if s - coin >= 0:
                result[s] += result[s - coin]
                
    return result[x]
```

Erona aiempaan funktioon `min_coins` verrattuna on, että funktio laskee minimien sijasta summia. Tapauksessa $$x=0$$ tulos on $$1$$, koska on yksi tapa muodostaa summa $$0$$ (ei valita mitään kolikkoja). Muissa tapauksissa funktio käy läpi vaihtoehdot, mikä on summan viimeinen kolikko, ja laskee mukaan nämä tapaukset.

Funktiota voidaan käyttää näin:

```python
print(count_coins(13, [1, 2, 5])) # 634
print(count_coins(13, [1, 4, 5])) # 88
print(count_coins(42, [1, 5, 6, 17])) # 1103532
```

Huomaa, että funktio laskee erikseen kaikki tavat järjestää kolikot listaan. Esimerkiksi funktio laskee erikseen mukaan ratkaisut $$[1,2,5,5]$$, $$[1,5,2,5]$$ ja $$[1,5,5,2]$$, vaikka ne muodostuvat samoista kolikoista. Vaikeampi tehtävä, joka on myös mahdollista ratkaista dynaamisella ohjelmoinnilla, on laskea mukaan jokainen samojen kolikoiden yhdistelmä vain kerran.

## Esimerkki: Alijonot

{: .note-title }
Tehtävä
<div class="note" markdown="1">

Annettuna on lista, jossa on $$n$$ kokonaislukua. Tehtäväsi on laskea, kuinka pitkä on listan _pisin nouseva alijono_ eli montako lukua listalta voidaan valita vasemmalta oikealle kulkien niin, että jokainen luku on edellistä suurempi.

Esimerkiksi listassa $$[4,1,5,6,3,4,1,8]$$ pisin nouseva alijono on $$[1,3,4,8]$$, jonka pituus on $$4$$.

</div>

Voimme lähestyä tehtävää dynaamisen ohjelmoinnin avulla laskemalla jokaiselle listan kohdalle, kuinka pitkä on pisin kyseiseen kohtaan päättyvä alijono. Esimerkissä laskettavat luvut ovat seuraavat:

Listan kohta | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
Pisin alijono | 1 | 1 | 2 | 3 | 2 | 3 | 1 | 4

Esimerkiksi pisin kohtaan $$5$$ päättyvä alijono on $$[1,3,4]$$, jonka pituus on $$3$$.

Seuraava funktio `find_longest` etsii annetun listan pisimmän nousevan alijonon dynaamisen ohjelmoinnin avulla:

```python
def find_longest(items):
    result = [0] * len(items)

    for i in range(len(items)):
        result[i] = 1
        for j in range(i):
            if items[j] < items[i]:
                result[i] = max(result[i], result[j] + 1)
    
    return max(result)
```

Funktio luo listan `result` ja laskee siihen jokaiseen kohtaan pisimmän nousevan alijonon pituuden listassa. Muuttuja `i` käy läpi listan kohdat ja muuttuja `j` käy läpi mahdolliset kohdat, jossa on alijonon edellinen luku. Jos edellinen luku on pienempi kuin nykyinen luku, alijonoa voidaan laajentaa.

Funktiota voidaan käyttää näin:

```python
print(find_longest([4, 1, 5, 6, 3, 4, 1, 8])) # 4
```

Tämän algoritmin aikavaativuus on $$O(n^2)$$, koska siinä on kaksi sisäkkäistä silmukkaa. Koska kaikkien alijonojen määrä on $$O(2^n)$$, tämä on merkittävä tehostus verrattuna siihen, että kaikki alijonot käytäisiin läpi.

## Esimerkki: Sulkulausekkeet

Joskus raa'an voiman ratkaisu on yllättävän helppoa muuttaa dynaamisen ohjelmoinnin ratkaisuksi. Näin on seuraavassa tehtävässä:

{: .note-title }
Tehtävä
<div class="note" markdown="1">

Sulkulauseke on suluista `(` ja `)` muodostuva merkkijono, joka vastaa oikein muodostettua matemaattista kaavaa. Tehtäväsi on laskea, montako sulkulauseketta voidaan muodostaa $$n$$ merkistä.

Esimerkiksi kun $$n=6$$, haluttu vastaus on $$5$$, koska mahdolliset sulkulausekkeet ovat `((()))`, `(())()`, `()(())`, `(()())` ja `()()()`.

</div>

Edellisessä luvussa ratkaisimme tehtävän raa'an voiman avulla näin:

```python
def count_sequences(n, d=0):
    if d < 0 or d > n:
        return 0
    if n == 0:
        return 1
    return count_sequences(n - 1, d + 1) + \
           count_sequences(n - 1, d - 1)
```

Tämän ratkaisun voi muuttaa tehokkaaksi dynaamisen ohjelmoinnin ratkaisuksi tallentamalla funktion tulokset muistiin sanakirjaan:

```python
result = {}

def count_sequences(n, d=0):
    if d < 0 or d > n:
        return 0
    if n == 0:
        return 1
    if (n, d) in result:
        return result[(n, d)]
    result[(n, d)] = count_sequences(n - 1, d + 1) + \
                     count_sequences(n - 1, d - 1)
    return result[(n, d)]
```

Ideana on, että sanakirja `result` sisältää vastaukset kaikille parametrien yhdistelmille, jotka funktio on jo laskenut. Tämän ansiosta samoja yhdistelmiä ei tarvitse laskea uudestaan ja funktio on tehokas. Tässä tapauksessa dynaamisen ohjelmoinnin osaongelmat ovat _pareja_ muotoa $$(n,d)$$, missä $$n$$ on lisättävien sulkujen määrä ja $$d$$ on muodostetun lausekkeen syvyys.

Alkuperäinen raa'an voiman funktio soveltui vain pienten tapausten laskemiseen, mutta dynaamisen ohjelmoinnin ansiosta voimme laskea myös suuria tapauksia. Esimerkiksi voimme laskea sulkulausekkeiden määrän, kun $$n=100$$:

```python
print(count_sequences(100)) # 1978261657756160653623774456
```

Koska jokainen funktion kutsu vie aikaa $$O(1)$$ ja erilaisia parametrien yhdistelmiä on $$O(n^2)$$, algoritmin aikavaativuus on $$O(n^2)$$.

Tämä tehtävä on mahdollista ratkaista myös toisella tavalla dynaamisella ohjelmoinnilla niin, että funktiolla on pelkkä parametri $$n$$:

```python
result = {}

def count_sequences(n):
    if n == 0:
        return 1
    if n in result:
        return result[n]
    count = 0
    for i in range(2, n + 1, 2):
        count += count_sequences(i - 2) * count_sequences(n - i)
    result[n] = count
    return count
```

Tässä ideana on käydä läpi kaikki tavat valita kohta, jossa on ensimmäistä alkusulkua `(` vastaava loppusulku `)`. Jokaisessa tavassa näiden sulkujen väliin sekä näiden sulkujen jälkeen tulee jokin sulkulauseke, minkä ansiosta lausekkeiden määrä saadaan kertomalla väliin ja jälkeen tulevien lausekkeiden määrät.

Tässä algoritmissa jokainen funktion kutsu vie aikaa $$O(n)$$ ja erilaisia parametrien yhdistelmiä on $$O(n)$$. Myös tämän algoritmin aikavaativuus on siis $$O(n^2)$$, vaikka algoritmien logiikka on hyvin erilainen.

## Sisäkkäinen rekursio

Rekursiolla toteutettu dynaaminen ohjelmointi voi aiheuttaa paljon sisäkkäistä rekursiota, mikä voi aiheuttaa ongelman koodin suorittamiseen. Esimerkiksi seuraava koodi ei toimi toivotulla tavalla:

```python
print(count_sequences(2000)) # ?
```

Koodin suoritus aiheuttaa virheen "RecursionError: maximum recursion depth exceeded in comparison" mikä tarkoittaa, että funktiota `count_sequences` kutsutaan liian monta kertaa rekursiivisesti.

Pythonissa sisäkkäisten rekursiokutsujen raja on usein oletuksena melko pieni, esimerkiksi 1000. Rajaa voidaan kuitenkin nostaa moduulin `sys` funktiolla `setrecursionlimit` seuraavasti:

```python
import sys
sys.setrecursionlimit(5000)
```

Tämän jälkeen koodin suorittaminen onnistuu:

```python
print(count_sequences(2000)) # 2046105521468021692642519982997827217179245642339057975844538099572176010191891863964968026156453752449015750569428595097318163634370154637380666882886375203359653243390929717431080443509007504772912973142253209352126946839844796747697638537600100637918819326569730982083021538057087711176285777909275869648636874856805956580057673173655666887003493944650164153396910927037406301799052584663611016897272893305532116292143271037140718751625839812072682464343153792956281748582435751481498598087586998603921577523657477775758899987954012641033870640665444651660246024318184109046864244732001962029120
```

Rekursiorajan kasvattaminen voi kuitenkin olla kyseenalainen ratkaisu, koska se saattaa aiheuttaa ongelmia Pythonin suoritusympäristössä. Toinen ratkaisu on muuttaa dynaamisen ohjelmoinnin toteutusta niin, että rekursion sijasta käytetäänkin silmukoita. Tarkastellaan esimerkkinä seuraavaa toteutusta:

```python
result = {}

def count_sequences(n, d=0):
    if d < 0 or d > n:
        return 0
    if n == 0:
        return 1
    if (n, d) in result:
        return result[(n, d)]
    result[(n, d)] = count_sequences(n - 1, d + 1) + \
                     count_sequences(n - 1, d - 1)
    return result[(n, d)]
```

Rekursio voidaan poistaa miettimällä, missä järjestyksessä funktio lisää osaongelmien vastaukset sanakirjaan `result`, ja toteuttamalla sitten vastaavan laskennan ilman rekursiota. Tässä tapauksessa laskenta voidaan toteuttaa näin:

```python
def count_sequences(n):
    result = {}
    result[(0, 0)] = 1
    for i in range(1, n + 1):
        result[(0, i)] = 0
    for i in range(1, n + 1):
        for j in range(0, n + 1):
            result[(i, j)] = 0
            if j + 1 <= n:
                result[(i, j)] += result[(i - 1, j + 1)]
            if j - 1 >= 0:
                result[(i, j)] += result[(i - 1, j - 1)]
    return result[(n, 0)]
```

Tämän toteutuksen etuna on, että siinä ei ole rekursiota eikä sitä käyttäessä tarvitse huolehtia Pythonin rekursiorajasta. Kuitenkin huonona puolena tällaisessa toteutuksessa täytyy suunnitella itse, missä järjestyksessä osaongelmat käsitellään, eikä sitä voi jättää rekursion vastuulle.
